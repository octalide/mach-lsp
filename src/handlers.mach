use std.io.console;
use std.text.parse;
use std.types.bool;

use analysis;
use documents;
use json;
use protocol;
use state;
use util;

fun parse_position(body: []u8, line_out: *u64, character_out: *u64) bool {
    val position_anchor: []u8 = "\"position\"";

    val line_raw: []u8 = json_extract_after(body, position_anchor, "\"line\"");
    if (line_raw.data == nil && line_raw.capacity == 0) {
        ret false;
    }

    val character_raw: []u8 = json_extract_after(body, position_anchor, "\"character\"");
    if (character_raw.data == nil && character_raw.capacity == 0) {
        slice_free(line_raw);
        ret false;
    }

    @line_out = parse_u64_dec(line_raw);
    @character_out = parse_u64_dec(character_raw);

    slice_free(line_raw);
    slice_free(character_raw);
    ret true;
}

fun append_location(builder: *SliceBuilder, uri: []u8, start_line: u64, start_char: u64, end_line: u64, end_char: u64) bool {
    val quoted_uri: []u8 = json_quote(uri);
    if (quoted_uri.data == nil && quoted_uri.capacity == 0) {
        ret false;
    }

    val start_line_str: []u8 = u64_to_string(start_line);
    if (start_line_str.data == nil && start_line_str.capacity == 0 && start_line != 0) {
        slice_free(quoted_uri);
        ret false;
    }

    val start_char_str: []u8 = u64_to_string(start_char);
    if (start_char_str.data == nil && start_char_str.capacity == 0 && start_char != 0) {
        slice_free(quoted_uri);
        slice_free(start_line_str);
        ret false;
    }

    val end_line_str: []u8 = u64_to_string(end_line);
    if (end_line_str.data == nil && end_line_str.capacity == 0 && end_line != 0) {
        slice_free(quoted_uri);
        slice_free(start_line_str);
        slice_free(start_char_str);
        ret false;
    }

    val end_char_str: []u8 = u64_to_string(end_char);
    if (end_char_str.data == nil && end_char_str.capacity == 0 && end_char != 0) {
        slice_free(quoted_uri);
        slice_free(start_line_str);
        slice_free(start_char_str);
        slice_free(end_line_str);
        ret false;
    }

    var ok: bool = slice_builder_append(builder, "[{\"uri\":");
    ok = ok && slice_builder_append(builder, quoted_uri);
    ok = ok && slice_builder_append(builder, ",\"range\":{\"start\":{\"line\":");
    ok = ok && slice_builder_append(builder, start_line_str);
    ok = ok && slice_builder_append(builder, ",\"character\":");
    ok = ok && slice_builder_append(builder, start_char_str);
    ok = ok && slice_builder_append(builder, "},\"end\":{\"line\":");
    ok = ok && slice_builder_append(builder, end_line_str);
    ok = ok && slice_builder_append(builder, ",\"character\":");
    ok = ok && slice_builder_append(builder, end_char_str);
    ok = ok && slice_builder_append(builder, "}}]");

    slice_free(quoted_uri);
    slice_free(start_line_str);
    slice_free(start_char_str);
    slice_free(end_line_str);
    slice_free(end_char_str);

    ret ok;
}

fun completion_kind_from_symbol(symbol_kind: u8) u64 {
    if (symbol_kind == SYMBOL_KIND_FUNCTION) { ret 3; }
    if (symbol_kind == SYMBOL_KIND_VALUE)    { ret 6; }
    if (symbol_kind == SYMBOL_KIND_ALIAS)    { ret 22; }
    if (symbol_kind == SYMBOL_KIND_STRUCT)   { ret 7; }
    if (symbol_kind == SYMBOL_KIND_UNION)    { ret 10; }
    ret 1;
}

fun handle_initialize(state_ptr: *ServerState, body: []u8) {
    var id_is_string: bool = false;
    var id: []u8 = json_extract_number(body, "\"id\"");
    if (id.data == nil && id.capacity == 0) {
        id = json_extract_string(body, "\"id\"");
        if (id.data != nil || id.capacity > 0) {
            id_is_string = true;
        }
    }

    if (id.data != nil || id.capacity > 0) {
        send_initialize_response(id, id_is_string);
    }
    or {
        write(STDERR, "mach-lsp error: initialize missing id\n");
    }

    state_clear_uri(state_ptr);
    state_clear_text(state_ptr);
    state_ptr.shutdown_requested = false;
    state_ptr.exit_status = 0;

    slice_free(id);
}

fun handle_shutdown(state_ptr: *ServerState, body: []u8) {
    var id_is_string: bool = false;
    var id: []u8 = json_extract_number(body, "\"id\"");
    if (id.data == nil && id.capacity == 0) {
        id = json_extract_string(body, "\"id\"");
        if (id.data != nil || id.capacity > 0) {
            id_is_string = true;
        }
    }

    if (id.data != nil || id.capacity > 0) {
        send_shutdown_response(id, id_is_string);
    }

    slice_free(id);
    state_ptr.shutdown_requested = true;
}

fun handle_did_open(state_ptr: *ServerState, body: []u8) {
    val anchor: []u8 = "\"textDocument\"";
    val uri: []u8 = json_extract_after(body, anchor, "\"uri\"");
    if (uri.data != nil || uri.capacity > 0) {
        state_replace_uri(state_ptr, uri);
    }
    or {
        slice_free(uri);
    }

    val text: []u8 = json_extract_after(body, anchor, "\"text\"");
    if (text.data != nil || text.capacity > 0) {
        state_replace_text(state_ptr, text);
    }
    or {
        slice_free(text);
    }
}

fun handle_hover(state_ptr: *ServerState, body: []u8) {
    var id_is_string: bool = false;
    var id: []u8 = json_extract_number(body, "\"id\"");
    if (id.data == nil && id.capacity == 0) {
        id = json_extract_string(body, "\"id\"");
        if (id.data != nil || id.capacity > 0) {
            id_is_string = true;
        }
    }

    if (id.data != nil || id.capacity > 0) {
        send_hover_response(state_ptr, id, id_is_string);
    }

    slice_free(id);
}

fun handle_definition(state_ptr: *ServerState, body: []u8) {
    var id_is_string: bool = false;
    var id: []u8 = json_extract_number(body, "\"id\"");
    if (id.data == nil && id.capacity == 0) {
        id = json_extract_string(body, "\"id\"");
        if (id.data != nil || id.capacity > 0) {
            id_is_string = true;
        }
    }

    if (id.data == nil && id.capacity == 0) {
        ret;
    }

    val anchor: []u8 = "\"textDocument\"";
    val uri: []u8 = json_extract_after(body, anchor, "\"uri\"");
    if (uri.data == nil && uri.capacity == 0) {
        send_null_response(id, id_is_string);
        slice_free(id);
        ret;
    }

    var line: u64 = 0;
    var character: u64 = 0;
    if (parse_position(body, (?line) :: *u64, (?character) :: *u64) == false) {
        send_null_response(id, id_is_string);
        slice_free(id);
        slice_free(uri);
        ret;
    }

    val doc: *Document = state_document_get(state_ptr, uri);
    if (doc == nil) {
        send_null_response(id, id_is_string);
        slice_free(id);
        slice_free(uri);
        ret;
    }

    var token_start: u64 = 0;
    var token_end: u64 = 0;
    val identifier: []u8 = document_identifier_at(
        doc,
        line,
        character,
        (?token_start) :: *u64,
        (?token_end) :: *u64
    );

    if (identifier.data == nil || identifier.capacity == 0) {
        send_null_response(id, id_is_string);
        slice_free(id);
        slice_free(uri);
        ret;
    }

    var symbol_entry: SymbolEntry;
    val entry_ptr: *SymbolEntry = (?symbol_entry) :: *SymbolEntry;
    if (analyze_find_symbol(doc, identifier, entry_ptr, true) == false) {
        send_null_response(id, id_is_string);
        slice_free(id);
        slice_free(uri);
        ret;
    }

    var start_line: u64 = 0;
    var start_character: u64 = 0;
    document_offset_to_position(doc, symbol_entry.name_start, (?start_line) :: *u64, (?start_character) :: *u64);

    var end_line: u64 = 0;
    var end_character: u64 = 0;
    document_offset_to_position(doc, symbol_entry.name_end, (?end_line) :: *u64, (?end_character) :: *u64);

    var builder: SliceBuilder;
    val builder_ptr: *SliceBuilder = (?builder) :: *SliceBuilder;
    slice_builder_init(builder_ptr);

    if (append_location(builder_ptr, doc.uri, start_line, start_character, end_line, end_character) == false) {
        slice_builder_dnit(builder_ptr);
        send_null_response(id, id_is_string);
        slice_free(id);
        slice_free(uri);
        ret;
    }

    val result: []u8 = slice_builder_finish(builder_ptr);
    send_success_response(id, id_is_string, result);
    slice_free(result);
    slice_free(id);
    slice_free(uri);
}

fun handle_completion(state_ptr: *ServerState, body: []u8) {
    var id_is_string: bool = false;
    var id: []u8 = json_extract_number(body, "\"id\"");
    if (id.data == nil && id.capacity == 0) {
        id = json_extract_string(body, "\"id\"");
        if (id.data != nil || id.capacity > 0) {
            id_is_string = true;
        }
    }

    if (id.data == nil && id.capacity == 0) {
        ret;
    }

    val anchor: []u8 = "\"textDocument\"";
    val uri: []u8 = json_extract_after(body, anchor, "\"uri\"");
    if (uri.data == nil && uri.capacity == 0) {
        send_success_response(id, id_is_string, "[]");
        slice_free(id);
        ret;
    }

    val doc: *Document = state_document_get(state_ptr, uri);
    if (doc == nil) {
        slice_free(uri);
        send_success_response(id, id_is_string, "[]");
        slice_free(id);
        ret;
    }

    var list: SymbolList;
    val list_ptr: *SymbolList = (?list) :: *SymbolList;
    symbol_list_init(list_ptr);

    if (analyze_collect_symbols(doc, list_ptr, true) == false) {
        symbol_list_dnit(list_ptr);
        slice_free(uri);
        send_success_response(id, id_is_string, "[]");
        slice_free(id);
        ret;
    }

    var builder: SliceBuilder;
    val builder_ptr: *SliceBuilder = (?builder) :: *SliceBuilder;
    slice_builder_init(builder_ptr);

    var ok: bool = slice_builder_append(builder_ptr, "[");
    var first: bool = true;

    var i: u64 = 0;
    for (i < list.count && ok) {
        val entry: *SymbolEntry = list.items + i;
        val name_slice: []u8 = symbol_entry_name(doc, entry);
        if (name_slice.data == nil || name_slice.capacity == 0) {
            i = i + 1;
            cnt;
        }

        val label: []u8 = json_quote(name_slice);
        if (label.data == nil && label.capacity == 0) {
            ok = false;
            brk;
        }

        val kind_value: u64 = completion_kind_from_symbol(entry.kind);
        val kind_text: []u8 = u64_to_string(kind_value);
        if (kind_text.data == nil && kind_text.capacity == 0 && kind_value != 0) {
            slice_free(label);
            ok = false;
            brk;
        }

        if (first == false) {
            ok = ok && slice_builder_append(builder_ptr, ",");
        }
        or {
            first = false;
        }

        ok = ok && slice_builder_append(builder_ptr, "{\"label\":");
        ok = ok && slice_builder_append(builder_ptr, label);
        ok = ok && slice_builder_append(builder_ptr, ",\"kind\":");
        ok = ok && slice_builder_append(builder_ptr, kind_text);
        ok = ok && slice_builder_append(builder_ptr, "}");

        slice_free(label);
        slice_free(kind_text);

        i = i + 1;
    }

    ok = ok && slice_builder_append(builder_ptr, "]");

    var result: []u8 = []u8{ nil, 0 };
    if (ok) {
        result = slice_builder_finish(builder_ptr);
    }
    or {
        slice_builder_dnit(builder_ptr);
        result = "[]";
    }

    send_success_response(id, id_is_string, result);
    if (ok) {
        slice_free(result);
    }

    symbol_list_dnit(list_ptr);
    slice_free(uri);
    slice_free(id);
}

fun handle_exit(state_ptr: *ServerState) {
    if (state_ptr.shutdown_requested == false) {
        state_ptr.exit_status = 1;
    }

    state_ptr.running = false;
}

fun handle_unknown(state_ptr: *ServerState, body: []u8) {
    var id_is_string: bool = false;
    var id: []u8 = json_extract_number(body, "\"id\"");
    if (id.data == nil && id.capacity == 0) {
        id = json_extract_string(body, "\"id\"");
        if (id.data != nil || id.capacity > 0) {
            id_is_string = true;
        }
    }

    if (id.data == nil && id.capacity == 0) {
        ret;
    }

    send_error_response(id, id_is_string);
    slice_free(id);
}

pub fun handle_message(state_ptr: *ServerState, body: []u8) bool {
    val method: []u8 = json_extract_string(body, "\"method\"");
    if (method.data == nil && method.capacity == 0) {
        slice_free(method);
        ret true;
    }

    var keep_running: bool = true;

    if (slice_equals(method, "initialize")) {
        handle_initialize(state_ptr, body);
    }
    or (slice_equals(method, "shutdown")) {
        handle_shutdown(state_ptr, body);
    }
    or (slice_equals(method, "exit")) {
        handle_exit(state_ptr);
        keep_running = false;
    }
    or (slice_equals(method, "textDocument/didOpen")) {
        handle_did_open(state_ptr, body);
    }
    or (slice_equals(method, "textDocument/hover")) {
        handle_hover(state_ptr, body);
    }
    or (slice_equals(method, "textDocument/definition")) {
        handle_definition(state_ptr, body);
    }
    or (slice_equals(method, "textDocument/completion")) {
        handle_completion(state_ptr, body);
    }
    or (slice_equals(method, "initialized")) {
    }
    or {
        handle_unknown(state_ptr, body);
    }

    slice_free(method);
    ret keep_running;
}
