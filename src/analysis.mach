use std.types.bool;
use std.types.size;
use std.types.string;
use std.types.result;

use allocator: std.allocator;
use mem:       std.memory;
use print:     std.print;

use ast:      mach.compiler.ast;
use config:   mach.config.config;
use parser:   mach.compiler.parser;
use pipeline: mach.compiler.pipeline;
use sema:    mach.compiler.sema;
use collect: mach.compiler.sema.collect;
use resolve: mach.compiler.sema.resolve;
use symbol:   mach.compiler.symbol;
use target:   mach.compiler.target;
use token:    mach.compiler.token;

use type:      mach.compiler.type;
use workspace: mls.workspace;

# mls.analysis: semantic analysis integration for LSP.
# ---
# provides lazy per-document analysis with caching. on first query
# for a document, parses and runs semantic analysis (tolerating errors
# for partial results). subsequent queries use the cached result until
# the document changes.

# --- result record ---

pub rec AnalysisResult {
    root:   *ast.Node;
    sem:    sema.Sema;
    source: str;
    ok:     bool;
}

# --- cache ---

val INITIAL_CACHE_CAP: usize = 16;

pub rec AnalysisCache {
    entries: *CacheEntry;
    count:   usize;
    cap:     usize;
    tgt:     target.Target;
    tgt_ok:  bool;
    alloc:   allocator.Allocator;
}

rec CacheEntry {
    uri:    str;
    result: AnalysisResult;
    stale:  bool;
}

pub fun cache_init(cache: *AnalysisCache, alloc: allocator.Allocator) {
    cache.entries = nil;
    cache.count = 0;
    cache.cap = 0;
    cache.alloc = alloc;
    cache.tgt_ok = false;

    var a: allocator.Allocator = alloc;
    val tgt_res: Result[target.Target, str] = target.host(?a);
    if (tgt_res.tag) {
        cache.tgt = tgt_res.value.ok;
        cache.tgt_ok = true;
    }
    or {
        print.eprintln("mach-lsp: analysis: failed to create host target");
    }
}

pub fun cache_deinit(cache: *AnalysisCache) {
    var i: usize = 0;
    for (i < cache.count) {
        result_free(?cache.entries[i].result, cache.alloc);
        workspace.free_str(cache.entries[i].uri, cache.alloc);
        i = i + 1;
    }

    if (cache.entries != nil && cache.cap > 0) {
        var a: allocator.Allocator = cache.alloc;
        allocator.allocator_free[CacheEntry](?a, cache.entries, cache.cap);
    }

    cache.entries = nil;
    cache.count = 0;
    cache.cap = 0;
}

# invalidate: mark a document's cached analysis as stale.
# called on textDocument/didChange and textDocument/didClose.
pub fun invalidate(cache: *AnalysisCache, uri: str) {
    var entry: *CacheEntry = find_entry(cache, uri);
    if (entry != nil) {
        entry.stale = true;
    }
}

# get_analysis: return analysis result for a document, running analysis if needed.
# returns nil if analysis cannot be performed (no target, allocation failure, etc.).
pub fun get_analysis(cache: *AnalysisCache, doc: *workspace.Document, ws: *workspace.Workspace) *AnalysisResult {
    if (doc == nil || doc.uri == nil || !cache.tgt_ok) { ret nil; }

    var entry: *CacheEntry = find_entry(cache, doc.uri);

    if (entry != nil && !entry.stale) {
        if (entry.result.ok) { ret ?entry.result; }
        ret nil;
    }

    # need to (re)analyze
    if (entry != nil) {
        result_free(?entry.result, cache.alloc);
    }
    or {
        # allocate new entry
        if (cache.count >= cache.cap) {
            if (!grow_cache(cache)) { ret nil; }
        }
        entry = ?cache.entries[cache.count];
        entry.uri = workspace.clone_str(doc.uri, cache.alloc);
        cache.count = cache.count + 1;
    }

    entry.stale = false;
    run_analysis(cache, entry, doc, ws);

    if (entry.result.ok) { ret ?entry.result; }
    ret nil;
}

# --- AST query functions ---

# find_node_at_offset: find the most specific AST node at a byte offset.
# returns the innermost identifier, field access, type name, or declaration
# name node whose token span contains the given offset.
pub fun find_node_at_offset(root: *ast.Node, offset: i32, source: str) *ast.Node {
    if (root == nil || offset < 0) { ret nil; }
    ret walk_node(root, offset, source);
}

# is_decl_name_hit: check if offset falls within a declaration's name region.
# scans forward from the keyword token through whitespace to find the name start.
fun is_decl_name_hit(node: *ast.Node, name: str, offset: i32, source: str) bool {
    if (name == nil || source == nil) { ret false; }
    val name_len: i32 = str_len(name)::i32;
    if (name_len == 0) { ret false; }

    # scan forward from end of keyword token, skipping whitespace
    var pos: i32 = node.tok.pos + node.tok.len;
    for (pos < offset + name_len + 16) {
        val ch: u8 = source[pos::usize];
        if (ch != 32 && ch != 9 && ch != 10 && ch != 13) { # not space/tab/newline/cr
            # found start of name — check if it matches and offset is within
            if (offset >= pos && offset < pos + name_len) {
                ret true;
            }
            ret false;
        }
        pos = pos + 1;
    }
    ret false;
}

# get_node_symbol: extract the resolved symbol from a node.
# returns nil if the node has no resolved symbol (e.g. unresolved external).
pub fun get_node_symbol(node: *ast.Node) *symbol.Symbol {
    if (node == nil || node.symbol == nil) { ret nil; }
    ret node.symbol::*symbol.Symbol;
}

# find_module_by_path: walk the sema's loaded modules list to find a module
# by its dot-separated path (e.g. "mls.handler"). returns nil if not found.
pub fun find_module_by_path(ar: *AnalysisResult, module_path: str) *sema.SemaModule {
    if (ar == nil || module_path == nil) { ret nil; }
    var mod: *sema.SemaModule = ar.sem.modules;
    for (mod != nil) {
        if (mod.path != nil && str_equals(mod.path, module_path)) {
            ret mod;
        }
        mod = mod.next;
    }
    ret nil;
}

# find_module_alias: look up a module alias name in the sema's current module.
# returns the aliased SemaModule, or nil if no match.
pub fun find_module_alias(ar: *AnalysisResult, alias_name: str) *sema.SemaModule {
    if (ar == nil || alias_name == nil) { ret nil; }
    if (ar.sem.current_module == nil) { ret nil; }

    var ma: *sema.ModuleAlias = ar.sem.current_module.aliases;
    for (ma != nil) {
        if (ma.alias != nil && str_equals(ma.alias, alias_name)) {
            ret ma.module;
        }
        ma = ma.next;
    }
    ret nil;
}

# get_ident_name: extract the identifier name from an IDENT node.
pub fun get_ident_name(node: *ast.Node) str {
    if (node == nil) { ret nil; }
    if (node.kind == ast.NODE_EXPR_IDENT) {
        ret node.info.ident_expr.name;
    }
    ret nil;
}

# get_field_name: extract the field name from a FIELD node.
pub fun get_field_name(node: *ast.Node) str {
    if (node == nil) { ret nil; }
    if (node.kind == ast.NODE_EXPR_FIELD) {
        ret node.info.field_expr.field;
    }
    ret nil;
}

# get_decl_name: extract the name string from a declaration node.
# works for FUN, VAL, VAR, REC, UNI, DEF, PARAM, FIELD.
pub fun get_decl_name(node: *ast.Node) str {
    if (node == nil) { ret nil; }
    val k: u8 = node.kind;
    if (k == ast.NODE_DECL_FUN)  { ret node.info.fun_decl.name; }
    if (k == ast.NODE_DECL_VAL || k == ast.NODE_DECL_VAR)  { ret node.info.var_decl.name; }
    if (k == ast.NODE_DECL_REC || k == ast.NODE_DECL_UNI)  { ret node.info.type_decl.name; }
    if (k == ast.NODE_DECL_DEF)  { ret node.info.def_decl.name; }
    if (k == ast.NODE_PARAM || k == ast.NODE_FIELD) { ret node.info.field_decl.name; }
    ret nil;
}

# is_decl_node: check if a node is a declaration (FUN/VAL/VAR/REC/UNI/DEF/PARAM/FIELD).
pub fun is_decl_node(node: *ast.Node) bool {
    if (node == nil) { ret false; }
    val k: u8 = node.kind;
    ret k == ast.NODE_DECL_FUN || k == ast.NODE_DECL_VAL || k == ast.NODE_DECL_VAR ||
        k == ast.NODE_DECL_REC || k == ast.NODE_DECL_UNI || k == ast.NODE_DECL_DEF ||
        k == ast.NODE_PARAM || k == ast.NODE_FIELD;
}

# get_decl_name_pos: compute the byte offset and length of a declaration's name in the source.
# returns false if the name cannot be located.
pub fun get_decl_name_pos(node: *ast.Node, source: str, out_pos: *i32, out_len: *i32) bool {
    if (node == nil || source == nil || out_pos == nil || out_len == nil) { ret false; }
    val name: str = get_decl_name(node);
    if (name == nil) { ret false; }
    val name_len: i32 = str_len(name)::i32;
    if (name_len == 0) { ret false; }

    # scan forward from end of keyword token, skipping whitespace
    var pos: i32 = node.tok.pos + node.tok.len;
    for (pos < node.tok.pos + node.tok.len + 16) {
        val ch: u8 = source[pos::usize];
        if (ch != 32 && ch != 9 && ch != 10 && ch != 13) {
            @out_pos = pos;
            @out_len = name_len;
            ret true;
        }
        pos = pos + 1;
    }
    ret false;
}

# find_use_at_offset: find a use declaration that contains the given offset.
# scans the program's top-level statement list for NODE_DECL_USE nodes
# and checks if the offset falls between consecutive statements.
pub fun find_use_at_offset(root: *ast.Node, offset: i32) *ast.Node {
    if (root == nil || root.kind != ast.NODE_PROGRAM) { ret nil; }
    val stmts: *ast.List = root.info.block_stmt.stmts;
    if (stmts == nil) { ret nil; }

    var i: i32 = 0;
    for (i < stmts.count) {
        val node: *ast.Node = stmts.nodes[i];
        if (node == nil) { i = i + 1; cnt; }

        # skip pub wrappers
        var inner: *ast.Node = node;
        if (inner.kind == ast.NODE_DECL_PUB) {
            inner = inner.info.wrapper.inner;
            if (inner == nil) { i = i + 1; cnt; }
        }

        if (inner.kind == ast.NODE_DECL_USE) {
            val start: i32 = node.tok.pos;
            # use next statement's position as end bound, or use a generous estimate
            var end: i32 = start + 256;
            if (i + 1 < stmts.count && stmts.nodes[i + 1] != nil) {
                end = stmts.nodes[i + 1].tok.pos;
            }
            if (offset >= start && offset < end) {
                ret inner;
            }
        }

        i = i + 1;
    }

    ret nil;
}

# get_use_path: extract the module path from a use declaration node.
pub fun get_use_path(node: *ast.Node) str {
    if (node == nil || node.kind != ast.NODE_DECL_USE) { ret nil; }
    ret node.info.use_decl.path;
}

# find_decl_in_module: search a module's top-level declarations for one named `name`.
# returns the declaration node (the inner node, unwrapped from pub), or nil.
pub fun find_decl_in_module(mod: *sema.SemaModule, name: str) *ast.Node {
    if (mod == nil || mod.ast == nil || name == nil) { ret nil; }
    val root: *ast.Node = mod.ast;
    if (root.kind != ast.NODE_PROGRAM) { ret nil; }
    val stmts: *ast.List = root.info.block_stmt.stmts;
    if (stmts == nil) { ret nil; }

    var i: i32 = 0;
    for (i < stmts.count) {
        val node: *ast.Node = stmts.nodes[i];
        if (node == nil) { i = i + 1; cnt; }

        var inner: *ast.Node = node;
        if (inner.kind == ast.NODE_DECL_PUB) {
            inner = inner.info.wrapper.inner;
            if (inner == nil) { i = i + 1; cnt; }
        }

        val k: u8 = inner.kind;
        if (k == ast.NODE_DECL_FUN) {
            if (inner.info.fun_decl.name != nil && str_equals(inner.info.fun_decl.name, name)) {
                ret inner;
            }
        }
        if (k == ast.NODE_DECL_REC || k == ast.NODE_DECL_UNI) {
            if (inner.info.type_decl.name != nil && str_equals(inner.info.type_decl.name, name)) {
                ret inner;
            }
        }
        if (k == ast.NODE_DECL_VAL || k == ast.NODE_DECL_VAR) {
            if (inner.info.var_decl.name != nil && str_equals(inner.info.var_decl.name, name)) {
                ret inner;
            }
        }
        if (k == ast.NODE_DECL_DEF) {
            if (inner.info.def_decl.name != nil && str_equals(inner.info.def_decl.name, name)) {
                ret inner;
            }
        }

        i = i + 1;
    }
    ret nil;
}

# get_type_name_path: extract the path string from a TYPE_NAME node.
pub fun get_type_name_path(node: *ast.Node) str {
    if (node == nil || node.kind != ast.NODE_TYPE_NAME) { ret nil; }
    ret node.info.type_name.path;
}

# get_object_record_type: given a FIELD expression node, extract the record type
# from the object's type (unwrapping pointers). returns nil if not a record.
pub fun get_object_record_type(node: *ast.Node) *type.Type {
    if (node == nil || node.kind != ast.NODE_EXPR_FIELD) { ret nil; }
    val obj: *ast.Node = node.info.field_expr.object;
    if (obj == nil || obj.type == nil) { ret nil; }

    var t: *type.Type = obj.type;
    # unwrap pointer types (*T, &T)
    if (t.kind == type.TYPE_POINTER && t.inner != nil) {
        t = t.inner;
    }
    if (t.kind == type.TYPE_RECORD || t.kind == type.TYPE_UNION) {
        ret t;
    }
    ret nil;
}

# find_record_module: find which SemaModule contains a record/union declaration
# matching the given type name. searches all loaded modules and current module.
pub fun find_record_module(ar: *AnalysisResult, record_name: str) *sema.SemaModule {
    if (ar == nil || record_name == nil) { ret nil; }

    # search loaded modules
    var mod: *sema.SemaModule = ar.sem.modules;
    for (mod != nil) {
        val decl: *ast.Node = find_decl_in_module(mod, record_name);
        if (decl != nil) {
            val k: u8 = decl.kind;
            if (k == ast.NODE_DECL_REC || k == ast.NODE_DECL_UNI) { ret mod; }
        }
        mod = mod.next;
    }

    # check current module
    if (ar.sem.current_module != nil) {
        val decl: *ast.Node = find_decl_in_module(ar.sem.current_module, record_name);
        if (decl != nil) {
            val k: u8 = decl.kind;
            if (k == ast.NODE_DECL_REC || k == ast.NODE_DECL_UNI) { ret ar.sem.current_module; }
        }
    }

    ret nil;
}

# find_field_in_record_decl: given a record declaration AST node, find the
# field declaration matching `field_name`. returns the NODE_FIELD node.
pub fun find_field_in_record_decl(decl: *ast.Node, field_name: str) *ast.Node {
    if (decl == nil || field_name == nil) { ret nil; }
    val k: u8 = decl.kind;
    if (k != ast.NODE_DECL_REC && k != ast.NODE_DECL_UNI) { ret nil; }

    val fields: *ast.List = decl.info.type_decl.fields;
    if (fields == nil) { ret nil; }

    var i: i32 = 0;
    for (i < fields.count) {
        val field: *ast.Node = fields.nodes[i];
        if (field != nil && field.kind == ast.NODE_FIELD) {
            if (field.info.field_decl.name != nil && str_equals(field.info.field_decl.name, field_name)) {
                ret field;
            }
        }
        i = i + 1;
    }
    ret nil;
}

# collect_references: find all AST nodes that reference a given symbol.
# fills the `out` array with up to `max` node pointers. returns the count.
# set `include_decl` to true to also include the declaration node itself.
pub fun collect_references(
    root: *ast.Node, sym: *symbol.Symbol,
    include_decl: bool,
    out: **ast.Node, max: i32
) i32 {
    if (root == nil || sym == nil || out == nil || max <= 0) { ret 0; }
    var rc: RefCollector;
    rc.target = sym::ptr;
    rc.out = out;
    rc.count = 0;
    rc.max = max;
    rc.include_decl = include_decl;
    rc.decl_node = sym.decl_node;
    collect_walk_node(?rc, root);
    ret rc.count;
}

rec RefCollector {
    target:       ptr;
    out:          **ast.Node;
    count:        i32;
    max:          i32;
    include_decl: bool;
    decl_node:    *ast.Node;
}

# --- internal ---

fun run_analysis(cache: *AnalysisCache, entry: *CacheEntry, doc: *workspace.Document, ws: *workspace.Workspace) {
    entry.result.root = nil;
    entry.result.ok = false;
    entry.result.source = doc.text;

    var a: allocator.Allocator = cache.alloc;

    # parse
    val pr: pipeline.ParseResult = pipeline.parse_source(doc.text, ?a, false);
    if (!pr.ok || pr.root == nil) {
        ret;
    }

    # set up sema
    var sem: sema.Sema = sema.init(?a, cache.tgt);

    # convert file URI to filesystem path for sema context
    var file_path: str = nil;
    file_path = workspace.uri_to_path(entry.uri, cache.alloc);

    # find the nearest mach.toml by walking up from the file
    var proj: workspace.ProjectConfig = workspace.find_project_config(file_path, cache.alloc);
    if (proj.ok) {
        print.eprint("mach-lsp: analysis: found mach.toml at ");
        print.eprintln(proj.root_path);

        val src_root: str = workspace.path_join(proj.root_path, proj.cfg.dir_src, cache.alloc);
        val dep_root: str = workspace.path_join(proj.root_path, proj.cfg.dir_dep, cache.alloc);
        if (src_root != nil) {
            sema.set_module_roots(?sem, proj.cfg.id, src_root, dep_root,
                proj.cfg.deps, proj.cfg.dep_count);
        }
    }
    or {
        # fall back to workspace-level config
        if (ws != nil && ws.cfg_ok) {
            val src_root: str = workspace.build_src_root(ws);
            val dep_root: str = workspace.build_dep_root(ws);
            if (src_root != nil) {
                sema.set_module_roots(?sem, ws.cfg.id, src_root, dep_root,
                    ws.cfg.deps, ws.cfg.dep_count);
            }
        }
        or {
            print.eprintln("mach-lsp: analysis: no mach.toml found");
        }
    }

    # create symbol table
    val table_res: Result[symbol.Table, str] = symbol.init(?a);
    if (!table_res.tag) {
        if (proj.root_path != nil) { workspace.free_str(proj.root_path, cache.alloc); }
        sema.dnit(?sem);
        ret;
    }

    val tbl_ptr_res: Result[*symbol.Table, allocator.AllocError] =
        allocator.allocator_alloc[symbol.Table](?a, 1);
    if (!tbl_ptr_res.tag) {
        if (proj.root_path != nil) { workspace.free_str(proj.root_path, cache.alloc); }
        sema.dnit(?sem);
        ret;
    }
    val tbl_ptr: *symbol.Table = tbl_ptr_res.value.ok;
    @tbl_ptr = table_res.value.ok;
    sem.symbols = tbl_ptr;

    # set up sema state — replicating sema/analyze.mach setup but running
    # passes individually so we can reset error_count between collect and
    # resolve. the standard analyze() skips resolve if collect had ANY errors,
    # which prevents local symbol resolution when dep modules have errors.
    var fp: str = file_path;
    if (fp == nil) { fp = entry.uri; }

    sem.file_path = fp;
    sem.source = doc.text;
    sem.error_count = 0;
    sem.had_error = false;

    # derive module path from file path relative to src root
    # e.g. "mach.compiler.target" for src/compiler/target.mach
    if (sem.module_path == nil && sem.src_root != nil && sem.project_id != nil && fp != nil) {
        sem.module_path = workspace.derive_module_path(fp, sem.src_root, sem.project_id, cache.alloc);
    }
    if (sem.module_path == nil) {
        if (sem.project_id != nil) {
            sem.module_path = sem.project_id;
        }
        or {
            sem.module_path = "main";
        }
    }

    # create SemaModule for the main module
    val mod_res: Result[*sema.SemaModule, allocator.AllocError] =
        allocator.allocator_alloc[sema.SemaModule](?a, 1);
    if (mod_res.tag) {
        val main_mod: *sema.SemaModule = mod_res.value.ok;
        main_mod.path = sem.module_path;
        main_mod.file_path = fp;
        main_mod.source = doc.text;
        main_mod.ast = pr.root;
        main_mod.is_analyzed = false;
        main_mod.next = nil;
        main_mod.aliases = nil;
        main_mod.imports = nil;
        main_mod.table = sem.symbols;
        sem.current_module = main_mod;
    }

    # push root scope
    val scope_res: Result[bool, str] = sema.push_scope(?sem);
    if (!scope_res.tag) {
        if (file_path != nil) { workspace.free_str(file_path, cache.alloc); }
        if (proj.root_path != nil) { workspace.free_str(proj.root_path, cache.alloc); }
        sema.dnit(?sem);
        ret;
    }

    # pass 1: collect declarations — loads dep modules, may produce errors
    collect.collect_declarations(?sem, pr.root);

    # reset error count so resolve passes run even when dep modules had errors.
    # the standard analyze() skips resolve if collect had ANY errors, which
    # prevents local symbol resolution when dep modules have errors.
    sem.error_count = 0;
    sem.had_error = false;

    # pass 2: resolve types
    resolve.resolve_types(?sem, pr.root);

    # reset again so resolve_functions runs
    sem.error_count = 0;
    sem.had_error = false;

    # pass 2b: resolve function bodies — sets node.symbol on identifier nodes
    resolve.resolve_functions(?sem, pr.root);

    # post-processing: patch node.symbol on declaration nodes.
    # sema only sets node.symbol on expression idents, not on declaration nodes.
    # walk expression idents and copy their symbol pointer to the declaration node.
    patch_decl_symbols(pr.root);

    # clean up scopes
    for (sem.current_scope != nil) {
        sema.pop_scope(?sem);
    }

    if (file_path != nil) { workspace.free_str(file_path, cache.alloc); }
    if (proj.root_path != nil) { workspace.free_str(proj.root_path, cache.alloc); }

    entry.result.root = pr.root;
    entry.result.sem = sem;
    entry.result.ok = true;
}

fun result_free(result: *AnalysisResult, alloc: allocator.Allocator) {
    if (result.ok) {
        sema.dnit(?result.sem);
    }
    result.root = nil;
    result.ok = false;
}

fun find_entry(cache: *AnalysisCache, uri: str) *CacheEntry {
    if (uri == nil) { ret nil; }
    var i: usize = 0;
    for (i < cache.count) {
        if (cache.entries[i].uri != nil && str_equals(cache.entries[i].uri, uri)) {
            ret ?cache.entries[i];
        }
        i = i + 1;
    }
    ret nil;
}

fun grow_cache(cache: *AnalysisCache) bool {
    var new_cap: usize = cache.cap;
    if (new_cap == 0) { new_cap = INITIAL_CACHE_CAP; }
    or { new_cap = new_cap + (new_cap >> 1) + 4; }

    var a: allocator.Allocator = cache.alloc;
    val res: Result[*CacheEntry, allocator.AllocError] =
        allocator.allocator_resize[CacheEntry](?a, cache.entries, cache.cap, new_cap);
    if (!res.tag) {
        print.eprintln("mach-lsp: analysis: failed to grow cache");
        ret false;
    }

    cache.entries = res.value.ok;

    var i: usize = cache.cap;
    for (i < new_cap) {
        mem.raw_zero((?cache.entries[i])::ptr, $size_of(CacheEntry));
        i = i + 1;
    }

    cache.cap = new_cap;
    ret true;
}

# --- declaration symbol patching ---
#
# sema only sets node.symbol on expression ident nodes, not on declaration
# nodes (val/var/fun/rec/uni/def/param/field). for LSP features like rename
# and go-to-definition on declaration names, we need the symbol pointer on
# the declaration node too.
#
# strategy: walk all expression idents with node.symbol set, extract
# sym.decl_node, and set decl_node.symbol = sym if it's currently nil.
# this is safe because sema never sets node.symbol on declarations.

fun patch_decl_symbols(root: *ast.Node) {
    if (root == nil) { ret; }
    patch_walk(root);
}

fun patch_walk(node: *ast.Node) {
    if (node == nil) { ret; }

    # if this is an expression ident with a resolved symbol, patch the declaration
    if (node.kind == ast.NODE_EXPR_IDENT && node.symbol != nil) {
        val sym: *symbol.Symbol = node.symbol::*symbol.Symbol;
        if (sym.decl_node != nil && sym.decl_node.symbol == nil) {
            sym.decl_node.symbol = node.symbol;
        }
    }

    # also patch call nodes — sema sets node.symbol on CALL nodes for the called function
    if (node.kind == ast.NODE_EXPR_CALL && node.symbol != nil) {
        val sym: *symbol.Symbol = node.symbol::*symbol.Symbol;
        if (sym.decl_node != nil && sym.decl_node.symbol == nil) {
            sym.decl_node.symbol = node.symbol;
        }
    }

    # also patch field access nodes
    if (node.kind == ast.NODE_EXPR_FIELD && node.symbol != nil) {
        val sym: *symbol.Symbol = node.symbol::*symbol.Symbol;
        if (sym.decl_node != nil && sym.decl_node.symbol == nil) {
            sym.decl_node.symbol = node.symbol;
        }
    }

    val kind: u8 = node.kind;

    if (kind == ast.NODE_DECL_PUB) {
        patch_walk(node.info.wrapper.inner);
        ret;
    }

    if (kind == ast.NODE_DECL_FUN) {
        patch_walk_list(node.info.fun_decl.params);
        patch_walk(node.info.fun_decl.body);
        patch_walk(node.info.fun_decl.ret_type);
        patch_walk(node.info.fun_decl.generics);
        ret;
    }

    if (kind == ast.NODE_DECL_VAL || kind == ast.NODE_DECL_VAR) {
        patch_walk(node.info.var_decl.type_node);
        patch_walk(node.info.var_decl.init);
        ret;
    }

    if (kind == ast.NODE_DECL_REC || kind == ast.NODE_DECL_UNI) {
        patch_walk_list(node.info.type_decl.fields);
        patch_walk(node.info.type_decl.generics);
        ret;
    }

    if (kind == ast.NODE_DECL_DEF) {
        patch_walk(node.info.def_decl.type_node);
        patch_walk(node.info.def_decl.generics);
        ret;
    }

    if (kind == ast.NODE_DECL_EXT) {
        patch_walk(node.info.ext_decl.inner);
        ret;
    }

    if (kind == ast.NODE_DECL_TEST) {
        patch_walk(node.info.test_decl.body);
        ret;
    }

    if (kind == ast.NODE_PROGRAM || kind == ast.NODE_STMT_LIST || kind == ast.NODE_STMT_BLOCK) {
        patch_walk_list(node.info.block_stmt.stmts);
        ret;
    }

    if (kind == ast.NODE_STMT_IF || kind == ast.NODE_STMT_OR ||
        kind == ast.NODE_COMPTIME_IF || kind == ast.NODE_COMPTIME_OR ||
        kind == ast.NODE_OR_BRANCH) {
        patch_walk(node.info.cond_stmt.cond);
        patch_walk(node.info.cond_stmt.body);
        patch_walk(node.info.cond_stmt.or_branch);
        ret;
    }

    if (kind == ast.NODE_STMT_FOR) {
        patch_walk(node.info.for_stmt.cond);
        patch_walk(node.info.for_stmt.body);
        ret;
    }

    if (kind == ast.NODE_STMT_EXPR || kind == ast.NODE_STMT_RET ||
        kind == ast.NODE_STMT_FIN || kind == ast.NODE_COMPTIME ||
        kind == ast.NODE_EXPR_PAREN) {
        patch_walk(node.info.wrapper.inner);
        ret;
    }

    if (kind == ast.NODE_EXPR_BINARY) {
        patch_walk(node.info.binary_expr.left);
        patch_walk(node.info.binary_expr.right);
        ret;
    }

    if (kind == ast.NODE_EXPR_UNARY ||
        kind == ast.NODE_EXPR_ADDR || kind == ast.NODE_EXPR_DEREF) {
        patch_walk(node.info.unary_expr.expr);
        ret;
    }

    if (kind == ast.NODE_EXPR_CALL) {
        patch_walk(node.info.call_expr.callee);
        patch_walk_list(node.info.call_expr.args);
        patch_walk(node.info.call_expr.type_args);
        ret;
    }

    if (kind == ast.NODE_EXPR_INDEX) {
        patch_walk(node.info.index_expr.base);
        patch_walk(node.info.index_expr.index);
        ret;
    }

    if (kind == ast.NODE_EXPR_FIELD) {
        patch_walk(node.info.field_expr.object);
        ret;
    }

    if (kind == ast.NODE_EXPR_CAST) {
        patch_walk(node.info.cast_expr.expr);
        patch_walk(node.info.cast_expr.type_node);
        ret;
    }

    if (kind == ast.NODE_EXPR_ARRAY_LIT) {
        patch_walk(node.info.array_lit.size);
        patch_walk(node.info.array_lit.type_node);
        patch_walk_list(node.info.array_lit.elements);
        ret;
    }

    if (kind == ast.NODE_EXPR_STRUCT_LIT) {
        patch_walk(node.info.struct_lit.type_node);
        patch_walk_list(node.info.struct_lit.fields);
        ret;
    }

    if (kind == ast.NODE_PARAM) {
        patch_walk(node.info.field_decl.type_node);
        ret;
    }

    if (kind == ast.NODE_FIELD) {
        patch_walk(node.info.field_decl.type_node);
        ret;
    }
}

fun patch_walk_list(list: *ast.List) {
    if (list == nil) { ret; }
    var i: i32 = 0;
    for (i < list.count) {
        patch_walk(list.nodes[i]);
        i = i + 1;
    }
}

# --- AST walking ---

fun walk_node(node: *ast.Node, offset: i32, source: str) *ast.Node {
    if (node == nil) { ret nil; }

    # check if this node is a name node whose token contains the offset
    if (is_name_node(node)) {
        if (offset >= node.tok.pos && offset < node.tok.pos + node.tok.len) {
            ret node;
        }
    }

    val kind: u8 = node.kind;

    # --- declarations ---

    if (kind == ast.NODE_DECL_PUB) {
        ret walk_node(node.info.wrapper.inner, offset, source);
    }

    if (kind == ast.NODE_DECL_FUN) {
        # check if offset is on the function name
        if (is_decl_name_hit(node, node.info.fun_decl.name, offset, source)) {
            ret node;
        }
        var found: *ast.Node = nil;
        found = walk_list(node.info.fun_decl.params, offset, source);
        if (found != nil) { ret found; }
        found = walk_node(node.info.fun_decl.body, offset, source);
        if (found != nil) { ret found; }
        found = walk_node(node.info.fun_decl.ret_type, offset, source);
        if (found != nil) { ret found; }
        found = walk_node(node.info.fun_decl.generics, offset, source);
        ret found;
    }

    if (kind == ast.NODE_DECL_VAL || kind == ast.NODE_DECL_VAR) {
        # check if offset is on the variable/constant name
        if (is_decl_name_hit(node, node.info.var_decl.name, offset, source)) {
            ret node;
        }
        var found: *ast.Node = nil;
        found = walk_node(node.info.var_decl.type_node, offset, source);
        if (found != nil) { ret found; }
        ret walk_node(node.info.var_decl.init, offset, source);
    }

    if (kind == ast.NODE_DECL_REC || kind == ast.NODE_DECL_UNI) {
        # check if offset is on the record/union name
        if (is_decl_name_hit(node, node.info.type_decl.name, offset, source)) {
            ret node;
        }
        var found: *ast.Node = nil;
        found = walk_list(node.info.type_decl.fields, offset, source);
        if (found != nil) { ret found; }
        ret walk_node(node.info.type_decl.generics, offset, source);
    }

    if (kind == ast.NODE_DECL_DEF) {
        # check if offset is on the def name
        if (is_decl_name_hit(node, node.info.def_decl.name, offset, source)) {
            ret node;
        }
        var found: *ast.Node = nil;
        found = walk_node(node.info.def_decl.type_node, offset, source);
        if (found != nil) { ret found; }
        ret walk_node(node.info.def_decl.generics, offset, source);
    }

    if (kind == ast.NODE_DECL_EXT) {
        ret walk_node(node.info.ext_decl.inner, offset, source);
    }

    if (kind == ast.NODE_DECL_TEST) {
        ret walk_node(node.info.test_decl.body, offset, source);
    }

    # --- statements ---

    if (kind == ast.NODE_PROGRAM || kind == ast.NODE_STMT_LIST || kind == ast.NODE_STMT_BLOCK) {
        ret walk_list(node.info.block_stmt.stmts, offset, source);
    }

    if (kind == ast.NODE_STMT_IF || kind == ast.NODE_STMT_OR ||
        kind == ast.NODE_COMPTIME_IF || kind == ast.NODE_COMPTIME_OR ||
        kind == ast.NODE_OR_BRANCH) {
        var found: *ast.Node = nil;
        found = walk_node(node.info.cond_stmt.cond, offset, source);
        if (found != nil) { ret found; }
        found = walk_node(node.info.cond_stmt.body, offset, source);
        if (found != nil) { ret found; }
        ret walk_node(node.info.cond_stmt.or_branch, offset, source);
    }

    if (kind == ast.NODE_STMT_FOR) {
        var found: *ast.Node = nil;
        found = walk_node(node.info.for_stmt.cond, offset, source);
        if (found != nil) { ret found; }
        ret walk_node(node.info.for_stmt.body, offset, source);
    }

    if (kind == ast.NODE_STMT_EXPR || kind == ast.NODE_STMT_RET ||
        kind == ast.NODE_STMT_FIN || kind == ast.NODE_COMPTIME ||
        kind == ast.NODE_EXPR_PAREN) {
        ret walk_node(node.info.wrapper.inner, offset, source);
    }

    # --- expressions ---

    if (kind == ast.NODE_EXPR_BINARY) {
        var found: *ast.Node = nil;
        found = walk_node(node.info.binary_expr.left, offset, source);
        if (found != nil) { ret found; }
        ret walk_node(node.info.binary_expr.right, offset, source);
    }

    if (kind == ast.NODE_EXPR_UNARY ||
        kind == ast.NODE_EXPR_ADDR || kind == ast.NODE_EXPR_DEREF) {
        ret walk_node(node.info.unary_expr.expr, offset, source);
    }

    if (kind == ast.NODE_EXPR_CALL) {
        var found: *ast.Node = nil;
        found = walk_node(node.info.call_expr.callee, offset, source);
        if (found != nil) { ret found; }
        found = walk_list(node.info.call_expr.args, offset, source);
        if (found != nil) { ret found; }
        ret walk_node(node.info.call_expr.type_args, offset, source);
    }

    if (kind == ast.NODE_EXPR_INDEX) {
        var found: *ast.Node = nil;
        found = walk_node(node.info.index_expr.base, offset, source);
        if (found != nil) { ret found; }
        ret walk_node(node.info.index_expr.index, offset, source);
    }

    if (kind == ast.NODE_EXPR_FIELD) {
        # field access: node.tok is the DOT, field name follows immediately after.
        # check if offset falls within the field name region.
        val field_name: str = node.info.field_expr.field;
        if (field_name != nil) {
            val field_start: i32 = node.tok.pos + node.tok.len;
            val field_len: i32 = str_len(field_name)::i32;
            if (offset >= field_start && offset < field_start + field_len) {
                ret node;
            }
        }
        ret walk_node(node.info.field_expr.object, offset, source);
    }

    if (kind == ast.NODE_EXPR_CAST) {
        var found: *ast.Node = nil;
        found = walk_node(node.info.cast_expr.expr, offset, source);
        if (found != nil) { ret found; }
        ret walk_node(node.info.cast_expr.type_node, offset, source);
    }

    if (kind == ast.NODE_EXPR_ARRAY_LIT) {
        var found: *ast.Node = nil;
        found = walk_node(node.info.array_lit.size, offset, source);
        if (found != nil) { ret found; }
        found = walk_node(node.info.array_lit.type_node, offset, source);
        if (found != nil) { ret found; }
        ret walk_list(node.info.array_lit.elements, offset, source);
    }

    if (kind == ast.NODE_EXPR_STRUCT_LIT) {
        var found: *ast.Node = nil;
        found = walk_node(node.info.struct_lit.type_node, offset, source);
        if (found != nil) { ret found; }
        ret walk_list(node.info.struct_lit.fields, offset, source);
    }

    # --- types ---

    if (kind == ast.NODE_TYPE_NAME) {
        # type names may contain dotted paths (e.g. "lsp_types.Server").
        # the token only covers the first identifier, but the full path
        # string gives us the real span. also walk generic args.
        val path: str = node.info.type_name.path;
        if (path != nil) {
            val path_len: i32 = str_len(path)::i32;
            if (offset >= node.tok.pos && offset < node.tok.pos + path_len) {
                ret node;
            }
        }
        ret walk_node(node.info.type_name.args, offset, source);
    }

    if (kind == ast.NODE_TYPE_PTR || kind == ast.NODE_TYPE_REF) {
        ret walk_node(node.info.type_ptr.inner, offset, source);
    }

    if (kind == ast.NODE_TYPE_ARRAY) {
        var found: *ast.Node = nil;
        found = walk_node(node.info.type_array.elem_type, offset, source);
        if (found != nil) { ret found; }
        ret walk_node(node.info.type_array.size, offset, source);
    }

    if (kind == ast.NODE_TYPE_FUN) {
        var found: *ast.Node = nil;
        found = walk_list(node.info.type_fun.params, offset, source);
        if (found != nil) { ret found; }
        ret walk_node(node.info.type_fun.ret_type, offset, source);
    }

    # --- misc ---

    if (kind == ast.NODE_GENERIC) {
        ret walk_list(node.info.generic_node.args, offset, source);
    }

    if (kind == ast.NODE_PARAM) {
        # check if offset is on the parameter name
        if (is_decl_name_hit(node, node.info.field_decl.name, offset, source)) {
            ret node;
        }
        ret walk_node(node.info.field_decl.type_node, offset, source);
    }

    if (kind == ast.NODE_FIELD) {
        # check if offset is on the field name
        if (is_decl_name_hit(node, node.info.field_decl.name, offset, source)) {
            ret node;
        }
        ret walk_node(node.info.field_decl.type_node, offset, source);
    }

    # leaf or unknown: no children to walk
    ret nil;
}

fun walk_list(list: *ast.List, offset: i32, source: str) *ast.Node {
    if (list == nil) { ret nil; }
    var i: i32 = 0;
    for (i < list.count) {
        val found: *ast.Node = walk_node(list.nodes[i], offset, source);
        if (found != nil) { ret found; }
        i = i + 1;
    }
    ret nil;
}

fun is_name_node(node: *ast.Node) bool {
    val k: u8 = node.kind;
    # NODE_EXPR_FIELD is handled specially in walk_node (tok is the DOT,
    # field name follows) — do not include it here.
    # NODE_TYPE_NAME is handled specially below for dotted paths.
    ret k == ast.NODE_EXPR_IDENT;
}

# --- reference collection walking ---

fun collect_walk_node(rc: *RefCollector, node: *ast.Node) {
    if (node == nil || rc.count >= rc.max) { ret; }

    # check if this node references the target symbol
    if (node.symbol == rc.target && node.symbol != nil) {
        # skip declaration node if include_decl is false
        if (node != rc.decl_node || rc.include_decl) {
            rc.out[rc.count] = node;
            rc.count = rc.count + 1;
            if (rc.count >= rc.max) { ret; }
        }
    }

    val kind: u8 = node.kind;

    if (kind == ast.NODE_DECL_PUB) {
        collect_walk_node(rc, node.info.wrapper.inner);
        ret;
    }

    if (kind == ast.NODE_DECL_FUN) {
        collect_walk_list(rc, node.info.fun_decl.params);
        collect_walk_node(rc, node.info.fun_decl.body);
        collect_walk_node(rc, node.info.fun_decl.ret_type);
        collect_walk_node(rc, node.info.fun_decl.generics);
        ret;
    }

    if (kind == ast.NODE_DECL_VAL || kind == ast.NODE_DECL_VAR) {
        collect_walk_node(rc, node.info.var_decl.type_node);
        collect_walk_node(rc, node.info.var_decl.init);
        ret;
    }

    if (kind == ast.NODE_DECL_REC || kind == ast.NODE_DECL_UNI) {
        collect_walk_list(rc, node.info.type_decl.fields);
        collect_walk_node(rc, node.info.type_decl.generics);
        ret;
    }

    if (kind == ast.NODE_DECL_DEF) {
        collect_walk_node(rc, node.info.def_decl.type_node);
        collect_walk_node(rc, node.info.def_decl.generics);
        ret;
    }

    if (kind == ast.NODE_DECL_EXT) {
        collect_walk_node(rc, node.info.ext_decl.inner);
        ret;
    }

    if (kind == ast.NODE_DECL_TEST) {
        collect_walk_node(rc, node.info.test_decl.body);
        ret;
    }

    if (kind == ast.NODE_PROGRAM || kind == ast.NODE_STMT_LIST || kind == ast.NODE_STMT_BLOCK) {
        collect_walk_list(rc, node.info.block_stmt.stmts);
        ret;
    }

    if (kind == ast.NODE_STMT_IF || kind == ast.NODE_STMT_OR ||
        kind == ast.NODE_COMPTIME_IF || kind == ast.NODE_COMPTIME_OR ||
        kind == ast.NODE_OR_BRANCH) {
        collect_walk_node(rc, node.info.cond_stmt.cond);
        collect_walk_node(rc, node.info.cond_stmt.body);
        collect_walk_node(rc, node.info.cond_stmt.or_branch);
        ret;
    }

    if (kind == ast.NODE_STMT_FOR) {
        collect_walk_node(rc, node.info.for_stmt.cond);
        collect_walk_node(rc, node.info.for_stmt.body);
        ret;
    }

    if (kind == ast.NODE_STMT_EXPR || kind == ast.NODE_STMT_RET ||
        kind == ast.NODE_STMT_FIN || kind == ast.NODE_COMPTIME ||
        kind == ast.NODE_EXPR_PAREN) {
        collect_walk_node(rc, node.info.wrapper.inner);
        ret;
    }

    if (kind == ast.NODE_EXPR_BINARY) {
        collect_walk_node(rc, node.info.binary_expr.left);
        collect_walk_node(rc, node.info.binary_expr.right);
        ret;
    }

    if (kind == ast.NODE_EXPR_UNARY ||
        kind == ast.NODE_EXPR_ADDR || kind == ast.NODE_EXPR_DEREF) {
        collect_walk_node(rc, node.info.unary_expr.expr);
        ret;
    }

    if (kind == ast.NODE_EXPR_CALL) {
        collect_walk_node(rc, node.info.call_expr.callee);
        collect_walk_list(rc, node.info.call_expr.args);
        collect_walk_node(rc, node.info.call_expr.type_args);
        ret;
    }

    if (kind == ast.NODE_EXPR_INDEX) {
        collect_walk_node(rc, node.info.index_expr.base);
        collect_walk_node(rc, node.info.index_expr.index);
        ret;
    }

    if (kind == ast.NODE_EXPR_FIELD) {
        collect_walk_node(rc, node.info.field_expr.object);
        ret;
    }

    if (kind == ast.NODE_EXPR_CAST) {
        collect_walk_node(rc, node.info.cast_expr.expr);
        collect_walk_node(rc, node.info.cast_expr.type_node);
        ret;
    }

    if (kind == ast.NODE_EXPR_ARRAY_LIT) {
        collect_walk_node(rc, node.info.array_lit.size);
        collect_walk_node(rc, node.info.array_lit.type_node);
        collect_walk_list(rc, node.info.array_lit.elements);
        ret;
    }

    if (kind == ast.NODE_EXPR_STRUCT_LIT) {
        collect_walk_node(rc, node.info.struct_lit.type_node);
        collect_walk_list(rc, node.info.struct_lit.fields);
        ret;
    }

    if (kind == ast.NODE_TYPE_PTR || kind == ast.NODE_TYPE_REF) {
        collect_walk_node(rc, node.info.type_ptr.inner);
        ret;
    }

    if (kind == ast.NODE_TYPE_ARRAY) {
        collect_walk_node(rc, node.info.type_array.elem_type);
        collect_walk_node(rc, node.info.type_array.size);
        ret;
    }

    if (kind == ast.NODE_TYPE_FUN) {
        collect_walk_list(rc, node.info.type_fun.params);
        collect_walk_node(rc, node.info.type_fun.ret_type);
        ret;
    }

    if (kind == ast.NODE_GENERIC) {
        collect_walk_list(rc, node.info.generic_node.args);
        ret;
    }

    if (kind == ast.NODE_PARAM) {
        collect_walk_node(rc, node.info.field_decl.type_node);
        ret;
    }

    if (kind == ast.NODE_FIELD) {
        collect_walk_node(rc, node.info.field_decl.type_node);
        ret;
    }
}

fun collect_walk_list(rc: *RefCollector, list: *ast.List) {
    if (list == nil || rc.count >= rc.max) { ret; }
    var i: i32 = 0;
    for (i < list.count) {
        collect_walk_node(rc, list.nodes[i]);
        if (rc.count >= rc.max) { ret; }
        i = i + 1;
    }
}
