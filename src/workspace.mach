use std.types.bool;
use std.types.size;
use std.types.string;
use std.types.result;

use allocator: std.allocator;
use mem:       std.memory;
use print:     std.print;

# mach_lsp.workspace: document and workspace state management.
# ---
# tracks open documents, their contents, and line offset tables for
# translating between byte offsets and LSP line/character positions.
#
# str is &char (a null-terminated C string pointer). all heap-allocated
# strings include +1 byte for the null terminator.

# --- constants ---

val INITIAL_DOC_CAP:  usize = 16;
val INITIAL_LINE_CAP: usize = 256;

# Document: a single open text document tracked by the server.
# ---
# uri:        heap-allocated null-terminated URI string
# text:       heap-allocated null-terminated source text
# text_len:   cached byte length of text (avoids repeated .len() walks)
# lines:      heap-allocated array of byte offsets for each line start
# line_count: number of entries in lines
# line_cap:   allocated capacity of lines array (in elements, not bytes)
pub rec Document {
    uri:        str;
    text:       str;
    text_len:   usize;
    lines:      *usize;
    line_count: usize;
    line_cap:   usize;
}

# Workspace: collection of all open documents.
# ---
# docs:     heap-allocated array of Document
# count:    number of open documents
# cap:      allocated capacity of docs array (in elements)
# alloc:    allocator used for all workspace-owned memory
pub rec Workspace {
    docs:  *Document;
    count: usize;
    cap:   usize;
    alloc: allocator.Allocator;
}

# init: initialize an empty workspace.
# ---
# ws:    pointer to the workspace to initialize
# alloc: allocator to use for all document storage
pub fun init(ws: *Workspace, alloc: allocator.Allocator) {
    ws.docs = nil;
    ws.count = 0;
    ws.cap = 0;
    ws.alloc = alloc;
}

# deinit: release all resources held by the workspace.
# ---
# ws:    pointer to the workspace to tear down
# alloc: allocator that owns the memory
pub fun deinit(ws: *Workspace, alloc: allocator.Allocator) {
    var i: usize = 0;
    for (i < ws.count) {
        doc_free(?ws.docs[i], alloc);
        i = i + 1;
    }

    if (ws.docs != nil && ws.cap > 0) {
        var a: allocator.Allocator = alloc;
        a.free[Document](ws.docs, ws.cap);
    }

    ws.docs = nil;
    ws.count = 0;
    ws.cap = 0;
}

# open: register a newly opened document in the workspace.
# ---
# ws:   pointer to the workspace
# uri:  document URI (null-terminated str)
# text: initial document text (null-terminated str)
# ret:  pointer to the new Document, or nil on allocation failure
pub fun open(ws: *Workspace, uri: str, text: str) *Document {
    # check if already open â€” if so, just update the text
    val existing: *Document = find(ws, uri);
    if (existing != nil) {
        update(ws, existing, text);
        ret existing;
    }

    # ensure capacity
    if (ws.count >= ws.cap) {
        if (!grow_docs(ws)) {
            ret nil;
        }
    }

    val doc: *Document = ?ws.docs[ws.count];

    # clone URI
    doc.uri = clone_str(uri, ws.alloc);
    if (uri != nil && doc.uri == nil) {
        ret nil;
    }

    # clone text
    doc.text = clone_str(text, ws.alloc);
    if (text != nil && doc.text == nil) {
        free_str(doc.uri, ws.alloc);
        doc.uri = nil;
        ret nil;
    }

    if (doc.text != nil) {
        doc.text_len = doc.text.len();
    }
    or {
        doc.text_len = 0;
    }

    # build line offset table
    doc.lines = nil;
    doc.line_count = 0;
    doc.line_cap = 0;
    rebuild_lines(doc, ws.alloc);

    ws.count = ws.count + 1;
    ret doc;
}

# close: remove a document from the workspace by URI.
# ---
# ws:  pointer to the workspace
# uri: URI of the document to close (null-terminated str)
# ret: true if the document was found and removed
pub fun close(ws: *Workspace, uri: str) bool {
    var idx: isize = -1;
    var i: usize = 0;
    for (i < ws.count) {
        if (ws.docs[i].uri != nil && ws.docs[i].uri.equals(uri)) {
            idx = i::isize;
            brk;
        }
        i = i + 1;
    }

    if (idx < 0) {
        ret false;
    }

    val remove_at: usize = idx::usize;
    doc_free(?ws.docs[remove_at], ws.alloc);

    # shift remaining documents down
    var j: usize = remove_at + 1;
    for (j < ws.count) {
        mem.raw_copy(
            (?ws.docs[j - 1])::ptr,
            (?ws.docs[j])::ptr,
            $size_of(Document)
        );
        j = j + 1;
    }

    ws.count = ws.count - 1;

    # zero out the now-unused trailing slot to prevent double-free
    mem.raw_zero((?ws.docs[ws.count])::ptr, $size_of(Document));

    ret true;
}

# update: replace the text of an already-open document.
# ---
# ws:   pointer to the workspace
# doc:  pointer to the document to update
# text: new text (null-terminated str)
pub fun update(ws: *Workspace, doc: *Document, text: str) {
    # free old text
    free_str(doc.text, ws.alloc);

    doc.text = clone_str(text, ws.alloc);
    if (doc.text != nil) {
        doc.text_len = doc.text.len();
    }
    or {
        doc.text_len = 0;
    }

    rebuild_lines(doc, ws.alloc);
}

# find: look up an open document by URI.
# ---
# ws:  pointer to the workspace
# uri: URI to search for (null-terminated str)
# ret: pointer to the matching Document, or nil if not found
pub fun find(ws: *Workspace, uri: str) *Document {
    if (uri == nil) {
        ret nil;
    }
    var i: usize = 0;
    for (i < ws.count) {
        if (ws.docs[i].uri != nil && ws.docs[i].uri.equals(uri)) {
            ret ?ws.docs[i];
        }
        i = i + 1;
    }
    ret nil;
}

# offset_to_position: convert a byte offset into a line/character pair.
# ---
# doc:       pointer to the document
# offset:    byte offset into the document text
# line_out:  receives the 0-based line number
# char_out:  receives the 0-based character (byte) offset within the line
pub fun offset_to_position(doc: &Document, offset: usize, line_out: *usize, char_out: *usize) {
    if (doc.line_count == 0 || doc.lines == nil) {
        @line_out = 0;
        @char_out = offset;
        ret;
    }

    # binary search for the line containing offset
    var low: usize = 0;
    var high: usize = doc.line_count;

    for (low + 1 < high) {
        val mid: usize = (low + high) >> 1;
        if (doc.lines[mid] <= offset) {
            low = mid;
        }
        or {
            high = mid;
        }
    }

    @line_out = low;
    val line_start: usize = doc.lines[low];
    if (offset >= line_start) {
        @char_out = offset - line_start;
    }
    or {
        @char_out = 0;
    }
}

# position_to_offset: convert a line/character pair into a byte offset.
# ---
# doc:       pointer to the document
# line:      0-based line number
# character: 0-based character (byte) offset within the line
# ret:       byte offset into the document text
pub fun position_to_offset(doc: &Document, line: usize, character: usize) usize {
    if (doc.line_count == 0 || doc.lines == nil) {
        ret character;
    }

    if (line >= doc.line_count) {
        val last: usize = doc.line_count - 1;
        ret doc.lines[last] + character;
    }

    ret doc.lines[line] + character;
}

# --- internal helpers ---

# doc_free: release all memory owned by a document.
fun doc_free(doc: *Document, alloc: allocator.Allocator) {
    free_str(doc.uri, alloc);
    free_str(doc.text, alloc);

    if (doc.lines != nil && doc.line_cap > 0) {
        var a: allocator.Allocator = alloc;
        a.free[usize](doc.lines, doc.line_cap);
    }

    doc.uri = nil;
    doc.text = nil;
    doc.text_len = 0;
    doc.lines = nil;
    doc.line_count = 0;
    doc.line_cap = 0;
}

# grow_docs: expand the workspace document array.
fun grow_docs(ws: *Workspace) bool {
    var new_cap: usize = ws.cap;
    if (new_cap == 0) {
        new_cap = INITIAL_DOC_CAP;
    }
    or {
        new_cap = new_cap + (new_cap >> 1) + 4;
    }

    var a: allocator.Allocator = ws.alloc;
    val res: Result[*Document, allocator.AllocError] = a.resize[Document](ws.docs, ws.cap, new_cap);
    if (res.is_err()) {
        print.eprintln("mach-lsp: workspace: failed to grow document array");
        ret false;
    }

    ws.docs = res.unwrap_ok();

    # zero the new slots
    var i: usize = ws.cap;
    for (i < new_cap) {
        mem.raw_zero((?ws.docs[i])::ptr, $size_of(Document));
        i = i + 1;
    }

    ws.cap = new_cap;
    ret true;
}

# rebuild_lines: recompute the line offset table for a document.
fun rebuild_lines(doc: *Document, alloc: allocator.Allocator) {
    var a: allocator.Allocator = alloc;

    # free existing table
    if (doc.lines != nil && doc.line_cap > 0) {
        a.free[usize](doc.lines, doc.line_cap);
    }
    doc.lines = nil;
    doc.line_count = 0;
    doc.line_cap = 0;

    if (doc.text == nil || doc.text_len == 0) {
        ret;
    }

    # count lines first (number of '\n' + 1)
    var count: usize = 1;
    var i: usize = 0;
    for (i < doc.text_len) {
        if (doc.text[i] == '\n') {
            count = count + 1;
        }
        i = i + 1;
    }

    var cap: usize = count;
    if (cap < INITIAL_LINE_CAP) {
        cap = INITIAL_LINE_CAP;
    }

    val res: Result[*usize, allocator.AllocError] = a.alloc[usize](cap);
    if (res.is_err()) {
        ret;
    }

    val lines: *usize = res.unwrap_ok();

    var line_idx: usize = 0;
    lines[line_idx] = 0;
    line_idx = line_idx + 1;

    i = 0;
    for (i < doc.text_len) {
        if (doc.text[i] == '\n') {
            lines[line_idx] = i + 1;
            line_idx = line_idx + 1;
        }
        i = i + 1;
    }

    doc.lines = lines;
    doc.line_count = line_idx;
    doc.line_cap = cap;
}

# clone_str: allocate a heap copy of a null-terminated string.
# ---
# the returned str is heap-allocated (len + 1 bytes including null terminator).
# the caller is responsible for freeing it with free_str().
# s:     string to clone
# alloc: allocator to use
# ret:   heap-allocated copy, or nil on failure
pub fun clone_str(s: str, alloc: allocator.Allocator) str {
    if (s == nil) {
        ret nil;
    }
    val len: usize = s.len();
    if (len == 0) {
        ret nil;
    }
    var a: allocator.Allocator = alloc;
    val res: Result[*u8, allocator.AllocError] = a.alloc[u8](len + 1);
    if (res.is_err()) {
        ret nil;
    }
    val buf: *u8 = res.unwrap_ok();
    mem.raw_copy(buf::ptr, s::ptr, len);
    buf[len] = 0;
    ret buf::str;
}

# make_str: create a null-terminated str from raw bytes and a length.
# ---
# the returned str is heap-allocated (len + 1 bytes including null terminator).
# data:  pointer to raw bytes (not necessarily null-terminated)
# len:   number of bytes to copy
# alloc: allocator to use
# ret:   heap-allocated null-terminated copy, or nil on failure
pub fun make_str(data: &u8, len: usize, alloc: allocator.Allocator) str {
    if (data == nil || len == 0) {
        ret nil;
    }
    var a: allocator.Allocator = alloc;
    val res: Result[*u8, allocator.AllocError] = a.alloc[u8](len + 1);
    if (res.is_err()) {
        ret nil;
    }
    val buf: *u8 = res.unwrap_ok();
    mem.raw_copy(buf::ptr, data::ptr, len);
    buf[len] = 0;
    ret buf::str;
}

# free_str: free a heap-allocated str.
# ---
# only call this on strings returned by clone_str() or make_str().
# never call on string literals or nil.
# s:     string to free
# alloc: allocator that owns the memory
pub fun free_str(s: str, alloc: allocator.Allocator) {
    if (s == nil) {
        ret;
    }
    val len: usize = s.len();
    var a: allocator.Allocator = alloc;
    a.free_bytes(s::ptr, len + 1, 1);
}

# --- tests ---

test "workspace: init produces empty workspace" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);
    if (ws.count != 0) { ret 0; }
    if (ws.docs != nil) { ret 0; }
    deinit(?ws, a);
    ret 1;
}

test "workspace: open adds a document" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///test.mach";
    val text: str = "use std.runtime;\n";
    val doc: *Document = open(?ws, uri, text);
    if (doc == nil) { ret 0; }
    if (ws.count != 1) { ret 0; }
    if (doc.text_len != text.len()) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: open same uri twice updates instead of duplicating" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///test.mach";
    val text1: str = "hello";
    val text2: str = "world!";

    val doc1: *Document = open(?ws, uri, text1);
    if (doc1 == nil) { ret 0; }
    if (ws.count != 1) { ret 0; }

    val doc2: *Document = open(?ws, uri, text2);
    if (doc2 == nil) { ret 0; }
    # should still be 1 document, not 2
    if (ws.count != 1) { ret 0; }
    if (doc2.text_len != text2.len()) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: open multiple documents" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri1: str = "file:///a.mach";
    val uri2: str = "file:///b.mach";
    val uri3: str = "file:///c.mach";
    val text: str = "# empty";

    open(?ws, uri1, text);
    open(?ws, uri2, text);
    open(?ws, uri3, text);

    if (ws.count != 3) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: find returns document by uri" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///find_me.mach";
    val text: str = "val x: i32 = 42;";
    open(?ws, uri, text);

    val found: *Document = find(?ws, uri);
    if (found == nil) { ret 0; }
    if (found.text_len != text.len()) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: find returns nil for unknown uri" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///exists.mach";
    val text: str = "# hi";
    open(?ws, uri, text);

    val found: *Document = find(?ws, "file:///nope.mach");
    if (found != nil) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: close removes document" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///close_me.mach";
    val text: str = "# close";
    open(?ws, uri, text);
    if (ws.count != 1) { ret 0; }

    val closed: bool = close(?ws, uri);
    if (!closed) { ret 0; }
    if (ws.count != 0) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: close returns false for unknown uri" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val closed: bool = close(?ws, "file:///nope.mach");
    if (closed) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: update replaces text" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///update_me.mach";
    val text1: str = "first";
    val text2: str = "second version";

    val doc: *Document = open(?ws, uri, text1);
    if (doc == nil) { ret 0; }
    if (doc.text_len != 5) { ret 0; }

    update(?ws, doc, text2);
    if (doc.text_len != 14) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: offset_to_position single line" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///pos.mach";
    val text: str = "hello world";
    val doc: *Document = open(?ws, uri, text);
    if (doc == nil) { ret 0; }

    var line: usize = 0;
    var ch: usize = 0;
    offset_to_position(doc, 6, ?line, ?ch);
    if (line != 0) { ret 0; }
    if (ch != 6) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: offset_to_position multi line" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///ml.mach";
    val text: str = "line1\nline2\nline3";
    val doc: *Document = open(?ws, uri, text);
    if (doc == nil) { ret 0; }

    # offset 8 should be line 1, character 2 ("ne2")
    var line: usize = 0;
    var ch: usize = 0;
    offset_to_position(doc, 8, ?line, ?ch);
    if (line != 1) { ret 0; }
    if (ch != 2) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: clone_str and free_str" {
    var a: allocator.Allocator = allocator.heap_allocator();
    val original: str = "hello world";
    val cloned: str = clone_str(original, a);
    if (cloned == nil) { ret 0; }
    if (!cloned.equals(original)) { ret 0; }
    if (cloned.len() != 11) { ret 0; }
    free_str(cloned, a);
    ret 1;
}

test "workspace: clone_str nil returns nil" {
    var a: allocator.Allocator = allocator.heap_allocator();
    val cloned: str = clone_str(nil, a);
    if (cloned != nil) { ret 0; }
    ret 1;
}

test "workspace: make_str creates null-terminated string" {
    var a: allocator.Allocator = allocator.heap_allocator();
    val source: str = "hello";
    val made: str = make_str(source::&u8, 3, a);
    if (made == nil) { ret 0; }
    if (made.len() != 3) { ret 0; }
    if (made[0] != 'h') { ret 0; }
    if (made[1] != 'e') { ret 0; }
    if (made[2] != 'l') { ret 0; }
    free_str(made, a);
    ret 1;
}
