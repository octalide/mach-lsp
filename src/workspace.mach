use std.types.bool;
use std.types.size;
use std.types.string;
use std.types.result;

use allocator: std.allocator;
use mem:       std.memory;
use print:     std.print;

# mach_lsp.workspace: document and workspace state management.
# ---
# tracks open documents, their contents, and line offset tables for
# translating between byte offsets and LSP line/character positions.

# --- constants ---

val INITIAL_DOC_CAP:  usize = 16;
val INITIAL_LINE_CAP: usize = 256;

# Document: a single open text document tracked by the server.
# ---
# uri:          heap-allocated URI string (e.g. "file:///path/to/file.mach")
# uri_len:      byte length of uri
# text:         heap-allocated source text
# text_len:     byte length of text
# lines:        heap-allocated array of byte offsets for each line start
# line_count:   number of entries in lines
# line_cap:     allocated capacity of lines array (in elements, not bytes)
pub rec Document {
    uri:        *u8;
    uri_len:    usize;
    text:       *u8;
    text_len:   usize;
    lines:      *usize;
    line_count: usize;
    line_cap:   usize;
}

# Workspace: collection of all open documents.
# ---
# docs:     heap-allocated array of Document
# count:    number of open documents
# cap:      allocated capacity of docs array (in elements)
# alloc:    allocator used for all workspace-owned memory
pub rec Workspace {
    docs:  *Document;
    count: usize;
    cap:   usize;
    alloc: allocator.Allocator;
}

# init: initialize an empty workspace.
# ---
# ws:    pointer to the workspace to initialize
# alloc: allocator to use for all document storage
pub fun init(ws: *Workspace, alloc: allocator.Allocator) {
    ws.docs = nil;
    ws.count = 0;
    ws.cap = 0;
    ws.alloc = alloc;
}

# deinit: release all resources held by the workspace.
# ---
# ws:    pointer to the workspace to tear down
# alloc: allocator that owns the memory
pub fun deinit(ws: *Workspace, alloc: allocator.Allocator) {
    var i: usize = 0;
    for (i < ws.count) {
        doc_free(?ws.docs[i], alloc);
        i = i + 1;
    }

    if (ws.docs != nil && ws.cap > 0) {
        alloc.free[Document](ws.docs, ws.cap);
    }

    ws.docs = nil;
    ws.count = 0;
    ws.cap = 0;
}

# open: register a newly opened document in the workspace.
# ---
# ws:       pointer to the workspace
# uri:      document URI bytes
# uri_len:  byte length of the URI
# text:     initial document text bytes
# text_len: byte length of the text
# ret:      pointer to the new Document, or nil on allocation failure
pub fun open(ws: *Workspace, uri: &u8, uri_len: usize, text: &u8, text_len: usize) *Document {
    # check if already open â€” if so, just update the text
    val existing: *Document = find(ws, uri, uri_len);
    if (existing != nil) {
        update(ws, existing, text, text_len);
        ret existing;
    }

    # ensure capacity
    if (ws.count >= ws.cap) {
        if (!grow_docs(ws)) {
            ret nil;
        }
    }

    val doc: *Document = ?ws.docs[ws.count];

    # clone URI
    doc.uri = clone_bytes(uri, uri_len, ws.alloc);
    if (uri_len > 0 && doc.uri == nil) {
        ret nil;
    }
    doc.uri_len = uri_len;

    # clone text
    doc.text = clone_bytes(text, text_len, ws.alloc);
    if (text_len > 0 && doc.text == nil) {
        ws.alloc.free[u8](doc.uri, uri_len);
        doc.uri = nil;
        ret nil;
    }
    doc.text_len = text_len;

    # build line offset table
    doc.lines = nil;
    doc.line_count = 0;
    doc.line_cap = 0;
    rebuild_lines(doc, ws.alloc);

    ws.count = ws.count + 1;
    ret doc;
}

# close: remove a document from the workspace by URI.
# ---
# ws:      pointer to the workspace
# uri:     URI bytes of the document to close
# uri_len: byte length of the URI
# ret:     true if the document was found and removed
pub fun close(ws: *Workspace, uri: &u8, uri_len: usize) bool {
    var idx: isize = -1;
    var i: usize = 0;
    for (i < ws.count) {
        if (str_eq(ws.docs[i].uri, ws.docs[i].uri_len, uri, uri_len)) {
            idx = i::isize;
            brk;
        }
        i = i + 1;
    }

    if (idx < 0) {
        ret false;
    }

    val remove_at: usize = idx::usize;
    doc_free(?ws.docs[remove_at], ws.alloc);

    # shift remaining documents down
    var j: usize = remove_at + 1;
    for (j < ws.count) {
        mem.raw_copy(
            (?ws.docs[j - 1])::ptr,
            (?ws.docs[j])::ptr,
            $size_of(Document),
        );
        j = j + 1;
    }

    ws.count = ws.count - 1;

    # zero out the now-unused trailing slot to prevent double-free
    mem.raw_zero((?ws.docs[ws.count])::ptr, $size_of(Document));

    ret true;
}

# update: replace the text of an already-open document.
# ---
# ws:       pointer to the workspace
# doc:      pointer to the document to update
# text:     new text bytes
# text_len: byte length of the new text
pub fun update(ws: *Workspace, doc: *Document, text: &u8, text_len: usize) {
    # free old text
    if (doc.text != nil && doc.text_len > 0) {
        ws.alloc.free[u8](doc.text, doc.text_len);
    }

    doc.text = clone_bytes(text, text_len, ws.alloc);
    doc.text_len = text_len;

    rebuild_lines(doc, ws.alloc);
}

# find: look up an open document by URI.
# ---
# ws:      pointer to the workspace
# uri:     URI bytes to search for
# uri_len: byte length of the URI
# ret:     pointer to the matching Document, or nil if not found
pub fun find(ws: *Workspace, uri: &u8, uri_len: usize) *Document {
    var i: usize = 0;
    for (i < ws.count) {
        if (str_eq(ws.docs[i].uri, ws.docs[i].uri_len, uri, uri_len)) {
            ret ?ws.docs[i];
        }
        i = i + 1;
    }
    ret nil;
}

# offset_to_position: convert a byte offset into a line/character pair.
# ---
# doc:       pointer to the document
# offset:    byte offset into the document text
# line_out:  receives the 0-based line number
# char_out:  receives the 0-based character (byte) offset within the line
pub fun offset_to_position(doc: &Document, offset: usize, line_out: *usize, char_out: *usize) {
    if (doc.line_count == 0 || doc.lines == nil) {
        @line_out = 0;
        @char_out = offset;
        ret;
    }

    # binary search for the line containing offset
    var low: usize = 0;
    var high: usize = doc.line_count;

    for (low + 1 < high) {
        val mid: usize = (low + high) >> 1;
        if (doc.lines[mid] <= offset) {
            low = mid;
        }
        or {
            high = mid;
        }
    }

    @line_out = low;
    val line_start: usize = doc.lines[low];
    if (offset >= line_start) {
        @char_out = offset - line_start;
    }
    or {
        @char_out = 0;
    }
}

# position_to_offset: convert a line/character pair into a byte offset.
# ---
# doc:       pointer to the document
# line:      0-based line number
# character: 0-based character (byte) offset within the line
# ret:       byte offset into the document text
pub fun position_to_offset(doc: &Document, line: usize, character: usize) usize {
    if (doc.line_count == 0 || doc.lines == nil) {
        ret character;
    }

    if (line >= doc.line_count) {
        val last: usize = doc.line_count - 1;
        ret doc.lines[last] + character;
    }

    ret doc.lines[line] + character;
}

# --- internal helpers ---

# doc_free: release all memory owned by a document.
fun doc_free(doc: *Document, alloc: allocator.Allocator) {
    if (doc.uri != nil && doc.uri_len > 0) {
        alloc.free[u8](doc.uri, doc.uri_len);
    }
    if (doc.text != nil && doc.text_len > 0) {
        alloc.free[u8](doc.text, doc.text_len);
    }
    if (doc.lines != nil && doc.line_cap > 0) {
        alloc.free[usize](doc.lines, doc.line_cap);
    }
    doc.uri = nil;
    doc.uri_len = 0;
    doc.text = nil;
    doc.text_len = 0;
    doc.lines = nil;
    doc.line_count = 0;
    doc.line_cap = 0;
}

# grow_docs: expand the workspace document array.
fun grow_docs(ws: *Workspace) bool {
    var new_cap: usize = ws.cap;
    if (new_cap == 0) {
        new_cap = INITIAL_DOC_CAP;
    }
    or {
        new_cap = new_cap + (new_cap >> 1) + 4;
    }

    val res: Result[*Document, allocator.AllocError] = ws.alloc.resize[Document](ws.docs, ws.cap, new_cap);
    if (res.is_err()) {
        print.eprintln("mach-lsp: workspace: failed to grow document array");
        ret false;
    }

    ws.docs = res.unwrap_ok();

    # zero the new slots
    var i: usize = ws.cap;
    for (i < new_cap) {
        mem.raw_zero((?ws.docs[i])::ptr, $size_of(Document));
        i = i + 1;
    }

    ws.cap = new_cap;
    ret true;
}

# rebuild_lines: recompute the line offset table for a document.
fun rebuild_lines(doc: *Document, alloc: allocator.Allocator) {
    # free existing table
    if (doc.lines != nil && doc.line_cap > 0) {
        alloc.free[usize](doc.lines, doc.line_cap);
    }
    doc.lines = nil;
    doc.line_count = 0;
    doc.line_cap = 0;

    if (doc.text == nil || doc.text_len == 0) {
        ret;
    }

    # count lines first (number of '\n' + 1)
    var count: usize = 1;
    var i: usize = 0;
    for (i < doc.text_len) {
        if (doc.text[i] == '\n') {
            count = count + 1;
        }
        i = i + 1;
    }

    var cap: usize = count;
    if (cap < INITIAL_LINE_CAP) {
        cap = INITIAL_LINE_CAP;
    }

    val res: Result[*usize, allocator.AllocError] = alloc.alloc[usize](cap);
    if (res.is_err()) {
        ret;
    }

    val lines: *usize = res.unwrap_ok();

    var line_idx: usize = 0;
    lines[line_idx] = 0;
    line_idx = line_idx + 1;

    i = 0;
    for (i < doc.text_len) {
        if (doc.text[i] == '\n') {
            lines[line_idx] = i + 1;
            line_idx = line_idx + 1;
        }
        i = i + 1;
    }

    doc.lines = lines;
    doc.line_count = line_idx;
    doc.line_cap = cap;
}

# clone_bytes: allocate a copy of a byte buffer.
fun clone_bytes(src: &u8, len: usize, alloc: allocator.Allocator) *u8 {
    if (src == nil || len == 0) {
        ret nil;
    }

    var a: allocator.Allocator = alloc;
    val res: Result[*u8, allocator.AllocError] = a.alloc[u8](len);
    if (res.is_err()) {
        ret nil;
    }

    val dst: *u8 = res.unwrap_ok();
    mem.raw_copy(dst::ptr, src::ptr, len);
    ret dst;
}

# str_eq: compare two byte buffers for equality.
fun str_eq(a: &u8, a_len: usize, b: &u8, b_len: usize) bool {
    if (a_len != b_len) {
        ret false;
    }

    var i: usize = 0;
    for (i < a_len) {
        if (a[i] != b[i]) {
            ret false;
        }
        i = i + 1;
    }

    ret true;
}

# --- tests ---

test "workspace: init produces empty workspace" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);
    if (ws.count != 0) { ret 0; }
    if (ws.docs != nil) { ret 0; }
    deinit(?ws, a);
    ret 1;
}

test "workspace: open adds a document" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///test.mach";
    val text: str = "use std.runtime;\n";
    val doc: *Document = open(?ws, uri.data, uri.len, text.data, text.len);
    if (doc == nil) { ret 0; }
    if (ws.count != 1) { ret 0; }
    if (doc.uri_len != uri.len) { ret 0; }
    if (doc.text_len != text.len) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: open same uri twice updates instead of duplicating" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///test.mach";
    val text1: str = "hello";
    val text2: str = "world!";

    val doc1: *Document = open(?ws, uri.data, uri.len, text1.data, text1.len);
    if (doc1 == nil) { ret 0; }
    if (ws.count != 1) { ret 0; }

    val doc2: *Document = open(?ws, uri.data, uri.len, text2.data, text2.len);
    if (doc2 == nil) { ret 0; }
    # should still be 1 document, not 2
    if (ws.count != 1) { ret 0; }
    if (doc2.text_len != text2.len) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: open multiple documents" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri1: str = "file:///a.mach";
    val uri2: str = "file:///b.mach";
    val uri3: str = "file:///c.mach";
    val text: str = "# empty";

    open(?ws, uri1.data, uri1.len, text.data, text.len);
    open(?ws, uri2.data, uri2.len, text.data, text.len);
    open(?ws, uri3.data, uri3.len, text.data, text.len);

    if (ws.count != 3) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: find returns document by uri" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///find_me.mach";
    val text: str = "val x: i32 = 42;";
    open(?ws, uri.data, uri.len, text.data, text.len);

    val found: *Document = find(?ws, uri.data, uri.len);
    if (found == nil) { ret 0; }
    if (found.text_len != text.len) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: find returns nil for unknown uri" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///exists.mach";
    val text: str = "# yes";
    open(?ws, uri.data, uri.len, text.data, text.len);

    val missing: str = "file:///nope.mach";
    val found: *Document = find(?ws, missing.data, missing.len);
    if (found != nil) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: close removes a document" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///close_me.mach";
    val text: str = "# bye";
    open(?ws, uri.data, uri.len, text.data, text.len);
    if (ws.count != 1) { ret 0; }

    val ok: bool = close(?ws, uri.data, uri.len);
    if (!ok) { ret 0; }
    if (ws.count != 0) { ret 0; }

    # should no longer be findable
    val found: *Document = find(?ws, uri.data, uri.len);
    if (found != nil) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: close returns false for unknown uri" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///nope.mach";
    val ok: bool = close(?ws, uri.data, uri.len);
    if (ok) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: close middle document shifts remaining" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri1: str = "file:///a.mach";
    val uri2: str = "file:///b.mach";
    val uri3: str = "file:///c.mach";
    val text: str = "# x";

    open(?ws, uri1.data, uri1.len, text.data, text.len);
    open(?ws, uri2.data, uri2.len, text.data, text.len);
    open(?ws, uri3.data, uri3.len, text.data, text.len);
    if (ws.count != 3) { ret 0; }

    # close the middle one
    val ok: bool = close(?ws, uri2.data, uri2.len);
    if (!ok) { ret 0; }
    if (ws.count != 2) { ret 0; }

    # first and third should still be findable
    if (find(?ws, uri1.data, uri1.len) == nil) { ret 0; }
    if (find(?ws, uri3.data, uri3.len) == nil) { ret 0; }
    # middle should be gone
    if (find(?ws, uri2.data, uri2.len) != nil) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: update replaces document text" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///update.mach";
    val text1: str = "val x: i32 = 1;";
    val doc: *Document = open(?ws, uri.data, uri.len, text1.data, text1.len);
    if (doc == nil) { ret 0; }
    if (doc.text_len != text1.len) { ret 0; }

    val text2: str = "val x: i64 = 999;\nval y: i64 = 0;\n";
    update(?ws, doc, text2.data, text2.len);
    if (doc.text_len != text2.len) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: rebuild_lines counts single line" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///one_line.mach";
    val text: str = "val x: i32 = 42;";
    val doc: *Document = open(?ws, uri.data, uri.len, text.data, text.len);
    if (doc == nil) { ret 0; }
    # no newlines => 1 line
    if (doc.line_count != 1) { ret 0; }
    if (doc.lines == nil) { ret 0; }
    # first line starts at offset 0
    if (doc.lines[0] != 0) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: rebuild_lines counts multiple lines" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///multi.mach";
    val text: str = "line0\nline1\nline2\n";
    val doc: *Document = open(?ws, uri.data, uri.len, text.data, text.len);
    if (doc == nil) { ret 0; }
    # 3 newlines => 4 lines (last is empty after trailing newline)
    if (doc.line_count != 4) { ret 0; }
    if (doc.lines[0] != 0) { ret 0; }
    if (doc.lines[1] != 6) { ret 0; }
    if (doc.lines[2] != 12) { ret 0; }
    if (doc.lines[3] != 18) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: rebuild_lines handles empty text" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///empty.mach";
    val empty: str = str{ data: nil, len: 0 };
    val doc: *Document = open(?ws, uri.data, uri.len, empty.data, empty.len);
    if (doc == nil) { ret 0; }
    if (doc.line_count != 0) { ret 0; }
    if (doc.lines != nil) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: offset_to_position first line" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///pos.mach";
    val text: str = "hello\nworld\n";
    val doc: *Document = open(?ws, uri.data, uri.len, text.data, text.len);
    if (doc == nil) { ret 0; }

    var line: usize = 0;
    var ch: usize = 0;

    # offset 3 = 'l' in "hello" => line 0, char 3
    offset_to_position(doc, 3, ?line, ?ch);
    if (line != 0) { ret 0; }
    if (ch != 3) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: offset_to_position second line" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///pos2.mach";
    val text: str = "hello\nworld\n";
    val doc: *Document = open(?ws, uri.data, uri.len, text.data, text.len);
    if (doc == nil) { ret 0; }

    var line: usize = 0;
    var ch: usize = 0;

    # offset 6 = 'w' in "world" => line 1, char 0
    offset_to_position(doc, 6, ?line, ?ch);
    if (line != 1) { ret 0; }
    if (ch != 0) { ret 0; }

    # offset 8 = 'r' in "world" => line 1, char 2
    offset_to_position(doc, 8, ?line, ?ch);
    if (line != 1) { ret 0; }
    if (ch != 2) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: offset_to_position at newline boundary" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///boundary.mach";
    val text: str = "ab\ncd\n";
    val doc: *Document = open(?ws, uri.data, uri.len, text.data, text.len);
    if (doc == nil) { ret 0; }

    var line: usize = 0;
    var ch: usize = 0;

    # offset 2 = '\n' => still line 0, char 2
    offset_to_position(doc, 2, ?line, ?ch);
    if (line != 0) { ret 0; }
    if (ch != 2) { ret 0; }

    # offset 3 = 'c' => line 1, char 0
    offset_to_position(doc, 3, ?line, ?ch);
    if (line != 1) { ret 0; }
    if (ch != 0) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: position_to_offset round-trips with offset_to_position" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///roundtrip.mach";
    val text: str = "use std.runtime;\nval x: i32 = 0;\nfun main() {}\n";
    val doc: *Document = open(?ws, uri.data, uri.len, text.data, text.len);
    if (doc == nil) { ret 0; }

    # test several offsets round-trip correctly
    var test_offset: usize = 0;
    for (test_offset < text.len) {
        var line: usize = 0;
        var ch: usize = 0;
        offset_to_position(doc, test_offset, ?line, ?ch);
        val back: usize = position_to_offset(doc, line, ch);
        if (back != test_offset) { ret 0; }
        test_offset = test_offset + 1;
    }

    deinit(?ws, a);
    ret 1;
}

test "workspace: position_to_offset line 0 char 0 is 0" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///origin.mach";
    val text: str = "abc\ndef\n";
    val doc: *Document = open(?ws, uri.data, uri.len, text.data, text.len);
    if (doc == nil) { ret 0; }

    val off: usize = position_to_offset(doc, 0, 0);
    if (off != 0) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: position_to_offset line beyond end clamps to last line" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///clamp.mach";
    val text: str = "abc\ndef\n";
    val doc: *Document = open(?ws, uri.data, uri.len, text.data, text.len);
    if (doc == nil) { ret 0; }

    # line 999 doesn't exist; should clamp to the last line start + character
    val off: usize = position_to_offset(doc, 999, 2);
    val last_start: usize = doc.lines[doc.line_count - 1];
    if (off != last_start + 2) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: update rebuilds line table" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val uri: str = "file:///rebuild.mach";
    val text1: str = "one line";
    val doc: *Document = open(?ws, uri.data, uri.len, text1.data, text1.len);
    if (doc == nil) { ret 0; }
    if (doc.line_count != 1) { ret 0; }

    val text2: str = "first\nsecond\nthird\n";
    update(?ws, doc, text2.data, text2.len);
    if (doc.line_count != 4) { ret 0; }
    if (doc.lines[0] != 0) { ret 0; }
    if (doc.lines[1] != 6) { ret 0; }
    if (doc.lines[2] != 13) { ret 0; }
    if (doc.lines[3] != 19) { ret 0; }

    deinit(?ws, a);
    ret 1;
}

test "workspace: clone_bytes produces independent copy" {
    var a: allocator.Allocator = allocator.heap_allocator();
    val src: str = "hello";
    val dst: *u8 = clone_bytes(src.data, src.len, a);
    if (dst == nil) { ret 0; }
    # must be a different pointer
    if (dst == src.data) { ret 0; }
    # contents must match
    var i: usize = 0;
    for (i < src.len) {
        if (dst[i] != src.data[i]) {
            a.free[u8](dst, src.len);
            ret 0;
        }
        i = i + 1;
    }
    a.free[u8](dst, src.len);
    ret 1;
}

test "workspace: clone_bytes returns nil for nil input" {
    var a: allocator.Allocator = allocator.heap_allocator();
    val dst: *u8 = clone_bytes(nil, 0, a);
    if (dst != nil) { ret 0; }
    ret 1;
}

test "workspace: str_eq matches equal buffers" {
    val a: str = "hello";
    val b: str = "hello";
    if (!str_eq(a.data, a.len, b.data, b.len)) { ret 0; }
    ret 1;
}

test "workspace: str_eq rejects different lengths" {
    val a: str = "hello";
    val b: str = "hi";
    if (str_eq(a.data, a.len, b.data, b.len)) { ret 0; }
    ret 1;
}

test "workspace: str_eq rejects different content" {
    val a: str = "hello";
    val b: str = "world";
    if (str_eq(a.data, a.len, b.data, b.len)) { ret 0; }
    ret 1;
}

test "workspace: str_eq matches empty buffers" {
    val empty: str = str{ data: nil, len: 0 };
    if (!str_eq(empty.data, empty.len, empty.data, empty.len)) { ret 0; }
    ret 1;
}

test "workspace: deinit on empty workspace is safe" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);
    deinit(?ws, a);
    if (ws.docs != nil) { ret 0; }
    if (ws.count != 0) { ret 0; }
    ret 1;
}

test "workspace: deinit frees all documents" {
    var a: allocator.Allocator = allocator.heap_allocator();
    var ws: Workspace;
    init(?ws, a);

    val text: str = "# content\n";
    var i: usize = 0;
    for (i < 10) {
        val uri_prefix: str = "file:///doc";
        # use index as single-digit suffix for unique URIs
        var uri_buf: [16]u8;
        mem.raw_copy((?uri_buf[0])::ptr, uri_prefix.data::ptr, uri_prefix.len);
        uri_buf[uri_prefix.len] = ('0' + i)::u8;
        val uri_len: usize = uri_prefix.len + 1;

        open(?ws, ?uri_buf[0], uri_len, text.data, text.len);
        i = i + 1;
    }
    if (ws.count != 10) { ret 0; }

    # deinit should clean up all 10 documents without crashing
    deinit(?ws, a);
    if (ws.count != 0) { ret 0; }
    ret 1;
}
