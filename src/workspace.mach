use std.types.bool;
use std.types.size;
use std.types.string;
use std.types.result;

use allocator: std.allocator;
use mem:       std.memory;
use print:     std.print;

use config: mach.config.config;

# mls.workspace: document and workspace state management.

val INITIAL_DOC_CAP:  usize = 16;
val INITIAL_LINE_CAP: usize = 256;

pub rec Document {
    uri:        str;
    text:       str;
    text_len:   usize;
    lines:      *usize;
    line_count: usize;
    line_cap:   usize;
}

pub rec Workspace {
    docs:      *Document;
    count:     usize;
    cap:       usize;
    alloc:     allocator.Allocator;
    root_path: str;
    cfg:       config.Config;
    cfg_ok:    bool;
}

pub fun init(ws: *Workspace, alloc: allocator.Allocator) {
    ws.docs = nil;
    ws.count = 0;
    ws.cap = 0;
    ws.alloc = alloc;
    ws.root_path = nil;
    ws.cfg_ok = false;
}

pub fun deinit(ws: *Workspace, alloc: allocator.Allocator) {
    var i: usize = 0;
    for (i < ws.count) {
        doc_free(?ws.docs[i], alloc);
        i = i + 1;
    }
    if (ws.docs != nil && ws.cap > 0) {
        var a: allocator.Allocator = alloc;
        allocator.allocator_free[Document](?a, ws.docs, ws.cap);
    }
    ws.docs = nil;
    ws.count = 0;
    ws.cap = 0;
}

# set_root: set the workspace root path and load mach.toml.
# root_uri should be a file:// URI from the initialize request.
pub fun set_root(ws: *Workspace, root_uri: str) {
    if (root_uri == nil) { ret; }

    # strip file:// prefix to get filesystem path
    ws.root_path = uri_to_path(root_uri, ws.alloc);
    if (ws.root_path == nil) { ret; }

    # build path to mach.toml
    val root_len: usize = str_len(ws.root_path);
    val toml_name: str = "mach.toml";
    val toml_len: usize = str_len(toml_name);

    # ensure root_path ends with /
    var sep: usize = 0;
    if (root_len > 0 && ws.root_path[root_len - 1] != '/') {
        sep = 1;
    }

    val path_len: usize = root_len + sep + toml_len;
    var a: allocator.Allocator = ws.alloc;
    val buf_res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, path_len + 1);
    if (!buf_res.tag) { ret; }
    val buf: *u8 = buf_res.value.ok;

    mem.raw_copy(buf::ptr, ws.root_path::ptr, root_len);
    if (sep > 0) { buf[root_len] = '/'; }
    mem.raw_copy((buf + root_len + sep)::ptr, toml_name::ptr, toml_len);
    buf[path_len] = 0;

    val config_path: str = buf::str;

    val cfg_res: Result[config.Config, str] = config.load(config_path, ?a);
    allocator.allocator_free[u8](?a, buf, path_len + 1);

    if (cfg_res.tag) {
        ws.cfg = cfg_res.value.ok;
        ws.cfg_ok = true;
        print.eprintln("mach-lsp: workspace: loaded mach.toml");
    }
    or {
        print.eprintln("mach-lsp: workspace: failed to load mach.toml");
    }
}

# uri_to_path: convert a file:// URI to a filesystem path.
# strips the "file://" prefix. caller owns the returned string.
pub fun uri_to_path(uri: str, alloc: allocator.Allocator) str {
    if (uri == nil) { ret nil; }
    val uri_len: usize = str_len(uri);

    # check for "file://" prefix (7 chars)
    val prefix: str = "file://";
    val prefix_len: usize = 7;
    if (uri_len <= prefix_len) { ret clone_str(uri, alloc); }

    var match: bool = true;
    var i: usize = 0;
    for (i < prefix_len) {
        if (uri[i] != prefix[i]) { match = false; brk; }
        i = i + 1;
    }

    if (match) {
        val path_len: usize = uri_len - prefix_len;
        val path_start: &u8 = (uri::ptr + prefix_len)::&u8;
        ret make_str(path_start, path_len, alloc);
    }

    ret clone_str(uri, alloc);
}

# build_src_root: construct absolute path to src directory.
pub fun build_src_root(ws: *Workspace) str {
    if (ws.root_path == nil || !ws.cfg_ok) { ret nil; }
    ret path_join(ws.root_path, ws.cfg.dir_src, ws.alloc);
}

# build_dep_root: construct absolute path to dep directory.
pub fun build_dep_root(ws: *Workspace) str {
    if (ws.root_path == nil || !ws.cfg_ok) { ret nil; }
    ret path_join(ws.root_path, ws.cfg.dir_dep, ws.alloc);
}

# path_join: join two path segments with /.
pub fun path_join(base: str, rel: str, alloc: allocator.Allocator) str {
    if (base == nil) { ret clone_str(rel, alloc); }
    if (rel == nil) { ret clone_str(base, alloc); }

    val base_len: usize = str_len(base);
    val rel_len: usize = str_len(rel);

    var sep: usize = 0;
    if (base_len > 0 && base[base_len - 1] != '/') { sep = 1; }

    val total: usize = base_len + sep + rel_len;
    var a: allocator.Allocator = alloc;
    val res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, total + 1);
    if (!res.tag) { ret nil; }
    val buf: *u8 = res.value.ok;

    mem.raw_copy(buf::ptr, base::ptr, base_len);
    if (sep > 0) { buf[base_len] = '/'; }
    mem.raw_copy((buf + base_len + sep)::ptr, rel::ptr, rel_len);
    buf[total] = 0;

    ret buf::str;
}

# uri_to_module_path: convert a file:// URI to a dot-separated module path.
# e.g. "file:///opt/.../src/server.mach" → "mls.server"
pub fun uri_to_module_path(uri: str, ws: *Workspace) str {
    if (uri == nil || !ws.cfg_ok || ws.root_path == nil) { ret nil; }

    val file_path: str = uri_to_path(uri, ws.alloc);
    if (file_path == nil) { ret nil; }

    val src_root: str = build_src_root(ws);
    if (src_root == nil) {
        free_str(file_path, ws.alloc);
        ret nil;
    }

    val fp_len: usize = str_len(file_path);
    val sr_len: usize = str_len(src_root);

    # check if file_path starts with src_root
    var prefix_len: usize = sr_len;
    if (fp_len <= prefix_len) {
        free_str(file_path, ws.alloc);
        free_str(src_root, ws.alloc);
        ret nil;
    }

    # compare prefix
    var match: bool = true;
    var i: usize = 0;
    for (i < sr_len) {
        if (file_path[i] != src_root[i]) { match = false; brk; }
        i = i + 1;
    }

    if (!match) {
        free_str(file_path, ws.alloc);
        free_str(src_root, ws.alloc);
        ret nil;
    }

    # skip trailing / on src_root
    if (prefix_len < fp_len && file_path[prefix_len] == '/') {
        prefix_len = prefix_len + 1;
    }

    # strip .mach suffix (5 chars)
    var suffix_len: usize = 0;
    val mach_suffix: str = ".mach";
    if (fp_len >= prefix_len + 5) {
        var suf_match: bool = true;
        var s: usize = 0;
        for (s < 5) {
            if (file_path[fp_len - 5 + s] != mach_suffix[s]) { suf_match = false; brk; }
            s = s + 1;
        }
        if (suf_match) { suffix_len = 5; }
    }

    # relative part: file_path[prefix_len .. fp_len - suffix_len]
    val rel_len: usize = fp_len - prefix_len - suffix_len;
    if (rel_len == 0) {
        free_str(file_path, ws.alloc);
        free_str(src_root, ws.alloc);
        ret nil;
    }

    # build: project_id + "." + relative (with / replaced by .)
    val pid: str = ws.cfg.id;
    var pid_len: usize = 0;
    if (pid != nil) { pid_len = str_len(pid); }

    val mod_len: usize = pid_len + 1 + rel_len;
    var a: allocator.Allocator = ws.alloc;
    val buf_res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, mod_len + 1);
    if (!buf_res.tag) {
        free_str(file_path, ws.alloc);
        free_str(src_root, ws.alloc);
        ret nil;
    }
    val buf: *u8 = buf_res.value.ok;

    var off: usize = 0;
    if (pid != nil) {
        mem.raw_copy(buf::ptr, pid::ptr, pid_len);
        off = pid_len;
    }
    buf[off] = '.';
    off = off + 1;

    # copy relative path, replacing / with .
    i = 0;
    for (i < rel_len) {
        val ch: u8 = file_path[prefix_len + i];
        if (ch == '/') { buf[off] = '.'; }
        or { buf[off] = ch; }
        off = off + 1;
        i = i + 1;
    }
    buf[off] = 0;

    free_str(file_path, ws.alloc);
    free_str(src_root, ws.alloc);

    ret buf::str;
}

pub fun open(ws: *Workspace, uri: str, text: str) *Document {
    val existing: *Document = find(ws, uri);
    if (existing != nil) {
        update(ws, existing, text);
        ret existing;
    }

    if (ws.count >= ws.cap) {
        if (!grow_docs(ws)) { ret nil; }
    }

    val doc: *Document = ?ws.docs[ws.count];

    doc.uri = clone_str(uri, ws.alloc);
    if (uri != nil && doc.uri == nil) { ret nil; }

    doc.text = clone_str(text, ws.alloc);
    if (text != nil && doc.text == nil) {
        free_str(doc.uri, ws.alloc);
        doc.uri = nil;
        ret nil;
    }

    if (doc.text != nil) { doc.text_len = str_len(doc.text); }
    or { doc.text_len = 0; }

    doc.lines = nil;
    doc.line_count = 0;
    doc.line_cap = 0;
    rebuild_lines(doc, ws.alloc);

    ws.count = ws.count + 1;
    ret doc;
}

pub fun close(ws: *Workspace, uri: str) bool {
    var idx: isize = -1;
    var i: usize = 0;
    for (i < ws.count) {
        if (ws.docs[i].uri != nil && str_equals(ws.docs[i].uri, uri)) {
            idx = i::isize;
            brk;
        }
        i = i + 1;
    }

    if (idx < 0) { ret false; }

    val remove_at: usize = idx::usize;
    doc_free(?ws.docs[remove_at], ws.alloc);

    var j: usize = remove_at + 1;
    for (j < ws.count) {
        mem.raw_copy((?ws.docs[j - 1])::ptr, (?ws.docs[j])::ptr, $size_of(Document));
        j = j + 1;
    }

    ws.count = ws.count - 1;
    mem.raw_zero((?ws.docs[ws.count])::ptr, $size_of(Document));
    ret true;
}

pub fun update(ws: *Workspace, doc: *Document, text: str) {
    free_str(doc.text, ws.alloc);
    doc.text = clone_str(text, ws.alloc);
    if (doc.text != nil) { doc.text_len = str_len(doc.text); }
    or { doc.text_len = 0; }
    rebuild_lines(doc, ws.alloc);
}

pub fun find(ws: *Workspace, uri: str) *Document {
    if (uri == nil) { ret nil; }
    var i: usize = 0;
    for (i < ws.count) {
        if (ws.docs[i].uri != nil && str_equals(ws.docs[i].uri, uri)) {
            ret ?ws.docs[i];
        }
        i = i + 1;
    }
    ret nil;
}

pub fun offset_to_position(doc: &Document, offset: usize, line_out: *usize, char_out: *usize) {
    if (doc.line_count == 0 || doc.lines == nil) {
        @line_out = 0;
        @char_out = offset;
        ret;
    }

    var low: usize = 0;
    var high: usize = doc.line_count;

    for (low + 1 < high) {
        val mid: usize = (low + high) >> 1;
        if (doc.lines[mid] <= offset) { low = mid; }
        or { high = mid; }
    }

    @line_out = low;
    val line_start: usize = doc.lines[low];
    if (offset >= line_start) { @char_out = offset - line_start; }
    or { @char_out = 0; }
}

pub fun position_to_offset(doc: &Document, line: usize, character: usize) usize {
    if (doc.line_count == 0 || doc.lines == nil) { ret character; }
    if (line >= doc.line_count) {
        val last: usize = doc.line_count - 1;
        ret doc.lines[last] + character;
    }
    ret doc.lines[line] + character;
}

fun doc_free(doc: *Document, alloc: allocator.Allocator) {
    free_str(doc.uri, alloc);
    free_str(doc.text, alloc);
    if (doc.lines != nil && doc.line_cap > 0) {
        var a: allocator.Allocator = alloc;
        allocator.allocator_free[usize](?a, doc.lines, doc.line_cap);
    }
    doc.uri = nil;
    doc.text = nil;
    doc.text_len = 0;
    doc.lines = nil;
    doc.line_count = 0;
    doc.line_cap = 0;
}

fun grow_docs(ws: *Workspace) bool {
    var new_cap: usize = ws.cap;
    if (new_cap == 0) { new_cap = INITIAL_DOC_CAP; }
    or { new_cap = new_cap + (new_cap >> 1) + 4; }

    var a: allocator.Allocator = ws.alloc;
    val res: Result[*Document, allocator.AllocError] = allocator.allocator_resize[Document](?a, ws.docs, ws.cap, new_cap);
    if (!res.tag) {
        print.eprintln("mach-lsp: workspace: failed to grow document array");
        ret false;
    }

    ws.docs = res.value.ok;

    var i: usize = ws.cap;
    for (i < new_cap) {
        mem.raw_zero((?ws.docs[i])::ptr, $size_of(Document));
        i = i + 1;
    }

    ws.cap = new_cap;
    ret true;
}

fun rebuild_lines(doc: *Document, alloc: allocator.Allocator) {
    var a: allocator.Allocator = alloc;

    if (doc.lines != nil && doc.line_cap > 0) {
        allocator.allocator_free[usize](?a, doc.lines, doc.line_cap);
    }
    doc.lines = nil;
    doc.line_count = 0;
    doc.line_cap = 0;

    if (doc.text == nil || doc.text_len == 0) { ret; }

    var count: usize = 1;
    var i: usize = 0;
    for (i < doc.text_len) {
        if (doc.text[i] == '\n') { count = count + 1; }
        i = i + 1;
    }

    var cap: usize = count;
    if (cap < INITIAL_LINE_CAP) { cap = INITIAL_LINE_CAP; }

    val res: Result[*usize, allocator.AllocError] = allocator.allocator_alloc[usize](?a, cap);
    if (!res.tag) { ret; }

    val lines: *usize = res.value.ok;

    var line_idx: usize = 0;
    lines[line_idx] = 0;
    line_idx = line_idx + 1;

    i = 0;
    for (i < doc.text_len) {
        if (doc.text[i] == '\n') {
            lines[line_idx] = i + 1;
            line_idx = line_idx + 1;
        }
        i = i + 1;
    }

    doc.lines = lines;
    doc.line_count = line_idx;
    doc.line_cap = cap;
}

pub fun clone_str(s: str, alloc: allocator.Allocator) str {
    if (s == nil) { ret nil; }
    val len: usize = str_len(s);
    if (len == 0) { ret nil; }
    var a: allocator.Allocator = alloc;
    val res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, len + 1);
    if (!res.tag) { ret nil; }
    val buf: *u8 = res.value.ok;
    mem.raw_copy(buf::ptr, s::ptr, len);
    buf[len] = 0;
    ret buf::str;
}

pub fun make_str(data: &u8, len: usize, alloc: allocator.Allocator) str {
    if (data == nil || len == 0) { ret nil; }
    var a: allocator.Allocator = alloc;
    val res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, len + 1);
    if (!res.tag) { ret nil; }
    val buf: *u8 = res.value.ok;
    mem.raw_copy(buf::ptr, data::ptr, len);
    buf[len] = 0;
    ret buf::str;
}

# find_project_config: walk up from a file path to find the nearest mach.toml.
# returns the project root directory and loaded config if found.
# the caller should free root_path when done.
pub rec ProjectConfig {
    root_path: str;
    cfg:       config.Config;
    ok:        bool;
}

pub fun find_project_config(file_path: str, alloc: allocator.Allocator) ProjectConfig {
    var result: ProjectConfig;
    result.root_path = nil;
    result.ok = false;

    if (file_path == nil) { ret result; }

    val fp_len: usize = str_len(file_path);
    if (fp_len == 0) { ret result; }

    var a: allocator.Allocator = alloc;

    # allocate a mutable buffer for path manipulation
    val buf_res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, fp_len + 16);
    if (!buf_res.tag) { ret result; }
    val buf: *u8 = buf_res.value.ok;
    mem.raw_copy(buf::ptr, file_path::ptr, fp_len);
    buf[fp_len] = 0;

    val toml_name: str = "/mach.toml";
    val toml_len: usize = 10;

    # find the directory of the file (last / before end)
    var dir_end: usize = fp_len;
    for (dir_end > 0) {
        dir_end = dir_end - 1;
        if (buf[dir_end] == '/') { brk; }
    }
    if (dir_end == 0) {
        allocator.allocator_free[u8](?a, buf, fp_len + 16);
        ret result;
    }

    # walk upward, max 32 levels
    var depth: i32 = 0;
    for (dir_end > 0 && depth < 32) {
        # build dir/mach.toml path
        val path_len: usize = dir_end + toml_len;
        val path_res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, path_len + 1);
        if (!path_res.tag) { brk; }
        val path_buf: *u8 = path_res.value.ok;
        mem.raw_copy(path_buf::ptr, buf::ptr, dir_end);
        mem.raw_copy((path_buf + dir_end)::ptr, toml_name::ptr, toml_len);
        path_buf[path_len] = 0;

        val config_path: str = path_buf::str;
        val cfg_res: Result[config.Config, str] = config.load(config_path, ?a);
        allocator.allocator_free[u8](?a, path_buf, path_len + 1);

        if (cfg_res.tag) {
            # found it — save the root dir
            result.cfg = cfg_res.value.ok;
            result.ok = true;
            result.root_path = make_str(buf::&u8, dir_end, alloc);
            allocator.allocator_free[u8](?a, buf, fp_len + 16);
            ret result;
        }

        # move up: find previous /
        if (dir_end == 0) { brk; }
        dir_end = dir_end - 1;
        for (dir_end > 0) {
            if (buf[dir_end] == '/') { brk; }
            dir_end = dir_end - 1;
        }
        depth = depth + 1;
    }

    allocator.allocator_free[u8](?a, buf, fp_len + 16);
    ret result;
}

pub fun path_to_uri(path: str, alloc: allocator.Allocator) str {
    if (path == nil) { ret nil; }
    val prefix: str = "file://";
    val prefix_len: usize = 7;
    val path_len: usize = str_len(path);
    val total: usize = prefix_len + path_len;
    var a: allocator.Allocator = alloc;
    val res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, total + 1);
    if (!res.tag) { ret nil; }
    val buf: *u8 = res.value.ok;
    mem.raw_copy(buf::ptr, prefix::ptr, prefix_len);
    mem.raw_copy((buf + prefix_len)::ptr, path::ptr, path_len);
    buf[total] = 0;
    ret buf::str;
}

pub fun free_str(s: str, alloc: allocator.Allocator) {
    if (s == nil) { ret; }
    val len: usize = str_len(s);
    var a: allocator.Allocator = alloc;
    allocator.allocator_free_bytes(?a, s::ptr, len + 1, 1);
}
