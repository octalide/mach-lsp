use std.types.bool;
use std.types.size;
use std.types.string;
use std.types.result;

use allocator: std.allocator;
use print:     std.print;

use transport: mach_lsp.transport;
use handler:   mach_lsp.handler;
use workspace: mach_lsp.workspace;
use json:      mach_lsp.json;
use lsp_types: mach_lsp.lsp_types;

# mach_lsp.server: top-level LSP server state and message loop.
# ---
# manages the server lifecycle (initialize -> running -> shutdown -> exit)
# and dispatches incoming JSON-RPC messages to the appropriate handlers.

# init: initialize a server instance.
# ---
# sets the server to the uninitialized state and prepares the allocator
# and workspace. the server is not yet ready to handle requests until
# it receives an `initialize` message from the client.
#
# srv: pointer to the server to initialize
pub fun init(srv: *lsp_types.Server) {
    srv.status = lsp_types.STATUS_UNINITIALIZED;
    srv.exit_code = 0;
    srv.alloc = allocator.heap_allocator();
    workspace.init(?srv.ws, srv.alloc);
}

# deinit: release all resources held by the server.
# ---
# tears down the workspace and marks the server as exited.
# the heap allocator itself does not require explicit teardown;
# all brk-backed memory is reclaimed on process exit.
#
# srv: pointer to the server to deinitialize
pub fun deinit(srv: *lsp_types.Server) {
    workspace.deinit(?srv.ws, srv.alloc);
    srv.status = lsp_types.STATUS_EXITED;
}

# run: enter the main message loop.
# ---
# reads JSON-RPC messages from stdin, dispatches them, and writes
# responses to stdout. blocks until the server exits (via the `exit`
# notification or an I/O error).
#
# srv: pointer to the initialized server
# ret: the exit code (0 = clean shutdown, 1 = error)
pub fun run(srv: *lsp_types.Server) i64 {
    for (srv.status != lsp_types.STATUS_EXITED) {
        var msg: transport.Message;
        val read_ok: bool = transport.read_message(?msg, srv.alloc);

        if (!read_ok) {
            # stdin closed or read failed
            if (srv.status == lsp_types.STATUS_SHUTTING_DOWN) {
                # expected: client closed connection after shutdown
                srv.status = lsp_types.STATUS_EXITED;
                brk;
            }

            print.eprintln("mach-lsp: error: failed to read message");
            srv.exit_code = 1;
            srv.status = lsp_types.STATUS_EXITED;
            brk;
        }

        dispatch(srv, ?msg);
        transport.message_free(?msg);
    }

    ret srv.exit_code;
}

# dispatch: route an incoming message to the correct handler.
# ---
# extracts the JSON-RPC `method` field and calls the matching handler.
# if the message has an `id` field it is a request; otherwise it is a
# notification. unknown requests receive an error response.
#
# srv: pointer to the server
# msg: pointer to the received message
fun dispatch(srv: *lsp_types.Server, msg: *transport.Message) {
    # msg.body is already a valid null-terminated str from the transport
    val body: str = msg.body;
    val method: str = json.extract_string(body, "\"method\"", srv.alloc);

    if (method == nil) {
        # no method field â€” likely a response or malformed message; ignore
        ret;
    }

    # --- lifecycle ---

    if (method.equals("initialize")) {
        json.free_str(method, srv.alloc);
        handler.handle_initialize(srv, body);
        ret;
    }

    if (method.equals("initialized")) {
        # notification: client acknowledges init; nothing to do
        json.free_str(method, srv.alloc);
        ret;
    }

    if (method.equals("shutdown")) {
        json.free_str(method, srv.alloc);
        handler.handle_shutdown(srv, body);
        ret;
    }

    if (method.equals("exit")) {
        json.free_str(method, srv.alloc);
        handler.handle_exit(srv);
        ret;
    }

    # --- reject everything before initialize completes ---

    if (srv.status != lsp_types.STATUS_RUNNING) {
        json.free_str(method, srv.alloc);
        val id: str = json.extract_raw(body, "\"id\"", srv.alloc);
        if (id != nil) {
            handler.send_error(srv, id, -32002, "server not initialized");
            json.free_str(id, srv.alloc);
        }
        ret;
    }

    # --- document synchronization ---

    if (method.equals("textDocument/didOpen")) {
        json.free_str(method, srv.alloc);
        handler.handle_did_open(srv, body);
        ret;
    }

    if (method.equals("textDocument/didChange")) {
        json.free_str(method, srv.alloc);
        handler.handle_did_change(srv, body);
        ret;
    }

    if (method.equals("textDocument/didClose")) {
        json.free_str(method, srv.alloc);
        handler.handle_did_close(srv, body);
        ret;
    }

    if (method.equals("textDocument/didSave")) {
        # notification: saved; no action needed for now
        json.free_str(method, srv.alloc);
        ret;
    }

    # --- language features ---

    if (method.equals("textDocument/hover")) {
        json.free_str(method, srv.alloc);
        handler.handle_hover(srv, body);
        ret;
    }

    if (method.equals("textDocument/definition")) {
        json.free_str(method, srv.alloc);
        handler.handle_definition(srv, body);
        ret;
    }

    if (method.equals("textDocument/completion")) {
        json.free_str(method, srv.alloc);
        handler.handle_completion(srv, body);
        ret;
    }

    if (method.equals("textDocument/documentSymbol")) {
        json.free_str(method, srv.alloc);
        handler.handle_document_symbol(srv, body);
        ret;
    }

    # --- fallback ---

    json.free_str(method, srv.alloc);

    val id: str = json.extract_raw(body, "\"id\"", srv.alloc);
    if (id != nil) {
        handler.send_error(srv, id, -32601, "method not found");
        json.free_str(id, srv.alloc);
    }

    # notifications with unknown methods are silently ignored per spec
}
