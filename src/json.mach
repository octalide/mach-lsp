use std.system.memory;
use std.types.bool;

use util;

fun json_is_escaped(data: []u8, index: u64) bool {
    if (index == 0) {
        ret false;
    }

    var back: i64 = (index::i64) - 1;
    var count: u64 = 0;

    for (back >= 0) {
        val ch: u8 = data[back::u64];
        if (ch != '\\') {
            brk;
        }

        count = count + 1;
        back = back - 1;
    }

    if ((count & 1) == 1) {
        ret true;
    }

    ret false;
}

fun json_find_key(data: []u8, key: []u8) i64 {
    if (key.capacity == 0) {
        ret -1;
    }

    var in_string: bool = false;
    var i: u64 = 0;
    for (i < data.capacity) {
        val ch: u8 = data[i];

        if (ch == '"') {
            if (json_is_escaped(data, i) == false) {
                if (in_string == false) {
                    if ((i + key.capacity) <= data.capacity) {
                        val slice: []u8 = []u8{ data.data + i, key.capacity };
                        if (slice_equals(slice, key)) {
                            ret i::i64;
                        }
                    }

                    in_string = true;
                }
                or {
                    in_string = false;
                }
            }
        }

        i = i + 1;
    }

    ret -1;
}

pub fun json_extract_string(data: []u8, key: []u8) []u8 {
    val idx: i64 = json_find_key(data, key);
    if (idx < 0) {
        ret []u8{ nil, 0 };
    }

    var pos: u64 = (idx::u64) + key.capacity;
    var colon_found: bool = false;
    for (pos < data.capacity) {
        val ch: u8 = data[pos];
        if (ch == ':') {
            colon_found = true;
            pos = pos + 1;
            brk;
        }

        pos = pos + 1;
    }

    if (colon_found == false) {
        ret []u8{ nil, 0 };
    }

    for (pos < data.capacity) {
        val ch: u8 = data[pos];
        if (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n') {
            pos = pos + 1;
        }
        or {
            brk;
        }
    }

    if (pos >= data.capacity) {
        ret []u8{ nil, 0 };
    }

    if (data[pos] != '"') {
        ret []u8{ nil, 0 };
    }

    pos = pos + 1;
    var scan: u64 = pos;
    var out_len: u64 = 0;
    for (scan < data.capacity) {
        val ch: u8 = data[scan];
        if (ch == '\\') {
            scan = scan + 1;
            if (scan >= data.capacity) {
                ret []u8{ nil, 0 };
            }

            scan = scan + 1;
            out_len = out_len + 1;
        }
        or (ch == '"') {
            brk;
        }
        or {
            scan = scan + 1;
            out_len = out_len + 1;
        }
    }

    if (scan >= data.capacity) {
        ret []u8{ nil, 0 };
    }

    if (out_len == 0) {
        ret []u8{ nil, 0 };
    }

    val buf: *u8 = allocate(out_len);
    if (buf == nil) {
        ret []u8{ nil, 0 };
    }

    var write: u64 = 0;
    scan = pos;
    for (scan < data.capacity) {
        val ch: u8 = data[scan];
        if (ch == '\\') {
            scan = scan + 1;
            if (scan >= data.capacity) {
                brk;
            }

            val esc: u8 = data[scan];
            if (esc == 'n') {
                @(buf + write) = 10;
            }
            or (esc == 'r') {
                @(buf + write) = 13;
            }
            or (esc == 't') {
                @(buf + write) = 9;
            }
            or (esc == '"') {
                @(buf + write) = 34;
            }
            or (esc == '\\') {
                @(buf + write) = 92;
            }
            or {
                @(buf + write) = esc;
            }

            write = write + 1;
            scan = scan + 1;
        }
        or (ch == '"') {
            brk;
        }
        or {
            @(buf + write) = ch;
            write = write + 1;
            scan = scan + 1;
        }
    }

    ret []u8{ buf, write };
}

pub fun json_extract_number(data: []u8, key: []u8) []u8 {
    val idx: i64 = json_find_key(data, key);
    if (idx < 0) {
        ret []u8{ nil, 0 };
    }

    var pos: u64 = (idx::u64) + key.capacity;
    var colon_found: bool = false;
    for (pos < data.capacity) {
        val ch: u8 = data[pos];
        if (ch == ':') {
            colon_found = true;
            pos = pos + 1;
            brk;
        }

        pos = pos + 1;
    }

    if (colon_found == false) {
        ret []u8{ nil, 0 };
    }

    for (pos < data.capacity) {
        val ch: u8 = data[pos];
        if (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n') {
            pos = pos + 1;
        }
        or {
            brk;
        }
    }

    if (pos >= data.capacity) {
        ret []u8{ nil, 0 };
    }

    val start: u64 = pos;
    for (pos < data.capacity) {
        val ch: u8 = data[pos];
        if ((ch >= '0' && ch <= '9') || ch == '-') {
            pos = pos + 1;
        }
        or {
            brk;
        }
    }

    val len: u64 = pos - start;
    if (len == 0) {
        ret []u8{ nil, 0 };
    }

    val buf: *u8 = allocate(len);
    if (buf == nil) {
        ret []u8{ nil, 0 };
    }

    memory_copy(buf, data.data + start, len);
    ret []u8{ buf, len };
}

pub fun json_extract_after(data: []u8, anchor: []u8, key: []u8) []u8 {
    val idx: i64 = json_find_key(data, anchor);
    if (idx < 0) {
        ret []u8{ nil, 0 };
    }

    val offset: u64 = (idx::u64) + anchor.capacity;
    if (offset >= data.capacity) {
        ret []u8{ nil, 0 };
    }

    val sub: []u8 = []u8{ data.data + offset, data.capacity - offset };
    ret json_extract_string(sub, key);
}

pub fun json_quote(data: []u8) []u8 {
    var encoded_len: u64 = 2;
    var i: u64 = 0;
    for (i < data.capacity) {
        val ch: u8 = data[i];
        if (ch == '"' || ch == '\\' || ch == 10 || ch == 13 || ch == 9) {
            encoded_len = encoded_len + 2;
        }
        or (ch < 32) {
            encoded_len = encoded_len + 1;
        }
        or {
            encoded_len = encoded_len + 1;
        }

        i = i + 1;
    }

    val buf: *u8 = allocate(encoded_len);
    if (buf == nil) {
        ret []u8{ nil, 0 };
    }

    var pos: u64 = 0;
    @(buf + pos) = '"';
    pos = pos + 1;

    i = 0;
    for (i < data.capacity) {
        val ch: u8 = data[i];
        if (ch == '"') {
            @(buf + pos) = '\\';
            @(buf + pos + 1) = '"';
            pos = pos + 2;
        }
        or (ch == '\\') {
            @(buf + pos) = '\\';
            @(buf + pos + 1) = '\\';
            pos = pos + 2;
        }
        or (ch == 10) {
            @(buf + pos) = '\\';
            @(buf + pos + 1) = 'n';
            pos = pos + 2;
        }
        or (ch == 13) {
            @(buf + pos) = '\\';
            @(buf + pos + 1) = 'r';
            pos = pos + 2;
        }
        or (ch == 9) {
            @(buf + pos) = '\\';
            @(buf + pos + 1) = 't';
            pos = pos + 2;
        }
        or (ch < 32) {
            @(buf + pos) = '?';
            pos = pos + 1;
        }
        or {
            @(buf + pos) = ch;
            pos = pos + 1;
        }

        i = i + 1;
    }

    @(buf + pos) = '"';
    pos = pos + 1;

    ret []u8{ buf, pos };
}
