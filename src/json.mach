use std.system.memory;
use std.types.bool;

use util;

pub fun json_extract_string(data: []u8, key: []u8) []u8 {
    val idx: i64 = find_subslice(data, key);
    if (idx < 0) {
        ret []u8{ nil, 0 };
    }

    var pos: u64 = (idx::u64) + key.length;
    var colon_found: bool = false;
    for (pos < data.length) {
        val ch: u8 = data[pos];
        if (ch == ':') {
            colon_found = true;
            pos = pos + 1;
            brk;
        }

        pos = pos + 1;
    }

    if (colon_found == false) {
        ret []u8{ nil, 0 };
    }

    for (pos < data.length) {
        val ch: u8 = data[pos];
        if (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n') {
            pos = pos + 1;
        }
        or {
            brk;
        }
    }

    if (pos >= data.length) {
        ret []u8{ nil, 0 };
    }

    if (data[pos] != '"') {
        ret []u8{ nil, 0 };
    }

    pos = pos + 1;
    var scan: u64 = pos;
    var out_len: u64 = 0;
    for (scan < data.length) {
        val ch: u8 = data[scan];
        if (ch == '\\') {
            scan = scan + 1;
            if (scan >= data.length) {
                ret []u8{ nil, 0 };
            }

            scan = scan + 1;
            out_len = out_len + 1;
        }
        or (ch == '"') {
            brk;
        }
        or {
            scan = scan + 1;
            out_len = out_len + 1;
        }
    }

    if (scan >= data.length) {
        ret []u8{ nil, 0 };
    }

    if (out_len == 0) {
        ret []u8{ nil, 0 };
    }

    val buf: *u8 = allocate(out_len);
    if (buf == nil) {
        ret []u8{ nil, 0 };
    }

    var write: u64 = 0;
    scan = pos;
    for (scan < data.length) {
        val ch: u8 = data[scan];
        if (ch == '\\') {
            scan = scan + 1;
            if (scan >= data.length) {
                brk;
            }

            val esc: u8 = data[scan];
            if (esc == 'n') {
                @(buf + write) = 10;
            }
            or (esc == 'r') {
                @(buf + write) = 13;
            }
            or (esc == 't') {
                @(buf + write) = 9;
            }
            or (esc == '"') {
                @(buf + write) = 34;
            }
            or (esc == '\\') {
                @(buf + write) = 92;
            }
            or {
                @(buf + write) = esc;
            }

            write = write + 1;
            scan = scan + 1;
        }
        or (ch == '"') {
            brk;
        }
        or {
            @(buf + write) = ch;
            write = write + 1;
            scan = scan + 1;
        }
    }

    ret []u8{ buf, write };
}

pub fun json_extract_number(data: []u8, key: []u8) []u8 {
    val idx: i64 = find_subslice(data, key);
    if (idx < 0) {
        ret []u8{ nil, 0 };
    }

    var pos: u64 = (idx::u64) + key.length;
    var colon_found: bool = false;
    for (pos < data.length) {
        val ch: u8 = data[pos];
        if (ch == ':') {
            colon_found = true;
            pos = pos + 1;
            brk;
        }

        pos = pos + 1;
    }

    if (colon_found == false) {
        ret []u8{ nil, 0 };
    }

    for (pos < data.length) {
        val ch: u8 = data[pos];
        if (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n') {
            pos = pos + 1;
        }
        or {
            brk;
        }
    }

    if (pos >= data.length) {
        ret []u8{ nil, 0 };
    }

    val start: u64 = pos;
    for (pos < data.length) {
        val ch: u8 = data[pos];
        if ((ch >= '0' && ch <= '9') || ch == '-') {
            pos = pos + 1;
        }
        or {
            brk;
        }
    }

    val len: u64 = pos - start;
    if (len == 0) {
        ret []u8{ nil, 0 };
    }

    val buf: *u8 = allocate(len);
    if (buf == nil) {
        ret []u8{ nil, 0 };
    }

    memory_copy(buf, data.data + start, len);
    ret []u8{ buf, len };
}

pub fun json_extract_after(data: []u8, anchor: []u8, key: []u8) []u8 {
    val idx: i64 = find_subslice(data, anchor);
    if (idx < 0) {
        ret []u8{ nil, 0 };
    }

    val offset: u64 = (idx::u64) + anchor.length;
    if (offset >= data.length) {
        ret []u8{ nil, 0 };
    }

    val sub: []u8 = []u8{ data.data + offset, data.length - offset };
    ret json_extract_string(sub, key);
}

pub fun json_quote(data: []u8) []u8 {
    var encoded_len: u64 = 2;
    var i: u64 = 0;
    for (i < data.length) {
        val ch: u8 = data[i];
        if (ch == '"' || ch == '\\' || ch == 10 || ch == 13 || ch == 9) {
            encoded_len = encoded_len + 2;
        }
        or (ch < 32) {
            encoded_len = encoded_len + 1;
        }
        or {
            encoded_len = encoded_len + 1;
        }

        i = i + 1;
    }

    val buf: *u8 = allocate(encoded_len);
    if (buf == nil) {
        ret []u8{ nil, 0 };
    }

    var pos: u64 = 0;
    @(buf + pos) = '"';
    pos = pos + 1;

    i = 0;
    for (i < data.length) {
        val ch: u8 = data[i];
        if (ch == '"') {
            @(buf + pos) = '\\';
            @(buf + pos + 1) = '"';
            pos = pos + 2;
        }
        or (ch == '\\') {
            @(buf + pos) = '\\';
            @(buf + pos + 1) = '\\';
            pos = pos + 2;
        }
        or (ch == 10) {
            @(buf + pos) = '\\';
            @(buf + pos + 1) = 'n';
            pos = pos + 2;
        }
        or (ch == 13) {
            @(buf + pos) = '\\';
            @(buf + pos + 1) = 'r';
            pos = pos + 2;
        }
        or (ch == 9) {
            @(buf + pos) = '\\';
            @(buf + pos + 1) = 't';
            pos = pos + 2;
        }
        or (ch < 32) {
            @(buf + pos) = '?';
            pos = pos + 1;
        }
        or {
            @(buf + pos) = ch;
            pos = pos + 1;
        }

        i = i + 1;
    }

    @(buf + pos) = '"';
    pos = pos + 1;

    ret []u8{ buf, pos };
}
