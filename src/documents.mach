use std.system.memory;
use std.types.bool;
use std.types.string;

use util;

pub val U64_BYTES: u64 = 8;
pub val DOCUMENT_SLOT_BYTES: u64 = 48;

pub str Document {
    uri: []u8;
    text: []u8;
    line_offsets: *u64;
    line_count: u64;
}

pub fun document_init(doc: *Document) {
    doc->uri = []u8{ nil, 0 };
    doc->text = []u8{ nil, 0 };
    doc->line_offsets = nil;
    doc->line_count = 0;
}

pub fun document_dnit(doc: *Document) {
    slice_free(doc->uri);
    slice_free(doc->text);

    if (doc->line_offsets != nil && doc->line_count > 0) {
        val bytes: u64 = doc->line_count * U64_BYTES;
        deallocate((doc->line_offsets) :: *u8, bytes);
    }

    doc->uri = []u8{ nil, 0 };
    doc->text = []u8{ nil, 0 };
    doc->line_offsets = nil;
    doc->line_count = 0;
}

fun document_set_uri(doc: *Document, value: []u8) bool {
    val copy: []u8 = clone_slice(value);
    if (value.length > 0 && (copy.data == nil || copy.length == 0)) {
        slice_free(copy);
        ret false;
    }

    slice_free(doc->uri);
    doc->uri = copy;
    ret true;
}

fun document_set_text(doc: *Document, value: []u8) bool {
    val copy: []u8 = clone_slice(value);
    if (value.length > 0 && (copy.data == nil || copy.length == 0)) {
        slice_free(copy);
        ret false;
    }

    slice_free(doc->text);
    doc->text = copy;
    ret true;
}

fun document_rebuild_lines(doc: *Document) bool {
    if (doc->line_offsets != nil && doc->line_count > 0) {
        val bytes_old: u64 = doc->line_count * U64_BYTES;
        deallocate((doc->line_offsets) :: *u8, bytes_old);
    }

    var line_total: u64 = 1;
    var i: u64 = 0;
    for (i < doc->text.length) {
        if (doc->text[i] == '\n') {
            line_total = line_total + 1;
        }
        i = i + 1;
    }

    val bytes_new: u64 = line_total * U64_BYTES;
    val buf: *u8 = allocate(bytes_new);
    if (buf == nil && line_total > 0) {
        doc->line_offsets = nil;
        doc->line_count = 0;
        ret false;
    }

    val offsets: *u64 = buf :: *u64;
    var current_line: u64 = 0;
    var offset: u64 = 0;
    offsets[current_line] = 0;
    current_line = current_line + 1;

    i = 0;
    for (i < doc->text.length) {
        if (doc->text[i] == '\n') {
            offsets[current_line] = i + 1;
            current_line = current_line + 1;
        }
        i = i + 1;
    }

    doc->line_offsets = offsets;
    doc->line_count = line_total;
    ret true;
}

pub fun document_assign(doc: *Document, uri: []u8, text: []u8) bool {
    if (document_set_uri(doc, uri) == false) {
        ret false;
    }

    if (document_set_text(doc, text) == false) {
        ret false;
    }

    ret document_rebuild_lines(doc);
}

pub fun document_update_text(doc: *Document, text: []u8) bool {
    if (document_set_text(doc, text) == false) {
        ret false;
    }

    ret document_rebuild_lines(doc);
}

pub fun document_offset_to_position(doc: *Document, offset: u64, line_out: *u64, column_out: *u64) {
    if (doc->line_count == 0 || doc->line_offsets == nil) {
        @line_out = 0;
        @column_out = offset;
        ret;
    }

    var low: u64 = 0;
    var high: u64 = doc->line_count;

    for (low + 1 < high) {
        val mid: u64 = (low + high) >> 1;
        val mid_offset: u64 = @(doc->line_offsets + mid);
        if (mid_offset <= offset) {
            low = mid;
        }
        or {
            high = mid;
        }
    }

    val line_start: u64 = @(doc->line_offsets + low);
    @line_out = low;
    if (offset >= line_start) {
        @column_out = offset - line_start;
    }
    or {
        @column_out = 0;
    }
}

pub fun document_position_to_offset(doc: *Document, line: u64, character: u64) u64 {
    if (doc->line_count == 0 || doc->line_offsets == nil) {
        ret character;
    }

    if (line >= doc->line_count) {
        val last_line_index: u64 = doc->line_count - 1;
        val last_start: u64 = @(doc->line_offsets + last_line_index);
        ret last_start + character;
    }

    val start: u64 = @(doc->line_offsets + line);
    ret start + character;
}

pub fun document_line_end_offset(doc: *Document, line: u64) u64 {
    if (doc->line_count == 0 || doc->line_offsets == nil) {
        ret doc->text.length;
    }

    if (line >= doc->line_count) {
        ret doc->text.length;
    }

    val start: u64 = @(doc->line_offsets + line);
    var end: u64 = doc->text.length;

    if ((line + 1) < doc->line_count) {
        end = @(doc->line_offsets + line + 1);
    }

    if (end > 0 && doc->text[end - 1] == '\n') {
        end = end - 1;
    }

    ret end;
}

pub str DocumentStore {
    items: *Document;
    count: u64;
    capacity: u64;
}

pub fun document_store_init(store: *DocumentStore) {
    store->items = nil;
    store->count = 0;
    store->capacity = 0;
}

pub fun document_store_dnit(store: *DocumentStore) {
    if (store->items != nil && store->capacity > 0) {
        var i: u64 = 0;
        for (i < store->count) {
            val doc_ptr: *Document = store->items + i;
            document_dnit(doc_ptr);
            i = i + 1;
        }

        val bytes: u64 = store->capacity * DOCUMENT_SLOT_BYTES;
        deallocate((store->items) :: *u8, bytes);
    }

    store->items = nil;
    store->count = 0;
    store->capacity = 0;
}

fun document_store_reserve(store: *DocumentStore, needed: u64) bool {
    if (needed <= store->capacity) {
        ret true;
    }

    var new_cap: u64 = store->capacity;
    if (new_cap == 0) {
        new_cap = 4;
    }

    for (new_cap < needed) {
        new_cap = new_cap + (new_cap >> 1) + 4;
    }

    val bytes_new: u64 = new_cap * DOCUMENT_SLOT_BYTES;

    var new_buf: *u8 = nil;
    if (store->items == nil) {
        new_buf = allocate(bytes_new);
    }
    or {
        val bytes_old: u64 = store->capacity * DOCUMENT_SLOT_BYTES;
        new_buf = reallocate((store->items) :: *u8, bytes_old, bytes_new);
    }
    if (new_buf == nil) {
        ret false;
    }

    store->items = new_buf :: *Document;
    store->capacity = new_cap;
    ret true;
}

pub fun document_store_get(store: *DocumentStore, uri: []u8) *Document {
    if (store->items == nil || store->count == 0) {
        ret nil;
    }

    var i: u64 = 0;
    for (i < store->count) {
        val doc_ptr: *Document = store->items + i;
        if (slice_equals(doc_ptr->uri, uri)) {
            ret doc_ptr;
        }
        i = i + 1;
    }

    ret nil;
}

pub fun document_store_upsert(store: *DocumentStore, uri: []u8, text: []u8) *Document {
    val existing: *Document = document_store_get(store, uri);
    if (existing != nil) {
        if (document_update_text(existing, text) == false) {
            ret nil;
        }

        ret existing;
    }

    val next_index: u64 = store->count;
    if (document_store_reserve(store, next_index + 1) == false) {
        ret nil;
    }

    val doc_ptr: *Document = store->items + next_index;
    document_init(doc_ptr);

    if (document_assign(doc_ptr, uri, text) == false) {
        document_dnit(doc_ptr);
        ret nil;
    }

    store->count = store->count + 1;
    ret doc_ptr;
}

pub fun document_store_remove(store: *DocumentStore, uri: []u8) bool {
    if (store->items == nil || store->count == 0) {
        ret false;
    }

    var index: i64 = -1;
    var i: u64 = 0;
    for (i < store->count) {
        if (slice_equals((store->items + i)->uri, uri)) {
            index = i::i64;
            brk;
        }
        i = i + 1;
    }

    if (index < 0) {
        ret false;
    }

    val target: *Document = store->items + index::u64;
    document_dnit(target);

    var src: u64 = (index::u64) + 1;
    var dst: u64 = index::u64;
    for (src < store->count) {
        val dst_ptr: *Document = store->items + dst;
        val src_ptr: *Document = store->items + src;

        memory_copy((dst_ptr) :: *u8, (src_ptr) :: *u8, DOCUMENT_SLOT_BYTES);
        src_ptr->uri = []u8{ nil, 0 };
        src_ptr->text = []u8{ nil, 0 };
        src_ptr->line_offsets = nil;
        src_ptr->line_count = 0;

        dst = dst + 1;
        src = src + 1;
    }

    store->count = store->count - 1;
    ret true;
}
