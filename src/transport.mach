use std.types.bool;
use std.types.size;
use std.types.string;
use std.types.result;

use allocator: std.allocator;
use mem:       std.memory;
use stream:    std.stream;
use stdio:     std.system.stdio;
use print:     std.print;

# mach_lsp.transport: JSON-RPC transport over stdin/stdout.
# ---
# implements the LSP base protocol: reads and writes messages framed with
# Content-Length headers over standard I/O. all messages are UTF-8 encoded
# JSON payloads preceded by HTTP-style headers terminated by \r\n\r\n.
#
# wire format (per LSP spec):
#   Content-Length: <byte-count>\r\n
#   \r\n
#   <JSON payload of exactly byte-count bytes>

# Message: a single JSON-RPC message read from the transport.
# ---
# body:     heap-allocated raw JSON payload bytes
# body_len: length of body in bytes
# alloc:    the allocator that owns body (needed for cleanup)
pub rec Message {
    body:     *u8;
    body_len: usize;
    alloc:    allocator.Allocator;
}

# message_free: release memory held by a message.
# ---
# msg: pointer to the message whose body should be freed
pub fun message_free(msg: *Message) {
    if (msg.body != nil && msg.body_len > 0) {
        msg.alloc.free[u8](msg.body, msg.body_len);
    }
    msg.body = nil;
    msg.body_len = 0;
}

# --- internal constants ---

val HEADER_BUF_INITIAL: usize = 512;
val HEADER_BUF_GROW:    usize = 256;
val CL_KEY:             str   = "content-length";
val CL_KEY_LEN:         usize = 14;
val HEADER_PREFIX:      str   = "Content-Length: ";
val CRLF_CRLF:          str   = "\r\n\r\n";

# read_message: block until a complete LSP message arrives on stdin.
# ---
# reads the header block one byte at a time until the \r\n\r\n terminator
# is found, extracts the Content-Length value, then reads exactly that many
# bytes of body payload.
#
# msg:   pointer to a Message that will be filled in on success
# alloc: allocator to use for all internal buffers and the resulting body
# ret:   true if a message was successfully read, false on EOF or error
pub fun read_message(msg: *Message, alloc: allocator.Allocator) bool {
    msg.body = nil;
    msg.body_len = 0;
    msg.alloc = alloc;

    var a: allocator.Allocator = alloc;
    var reader: stream.Reader = stdio.stdin();

    # --- read header block ---

    var hdr_cap: usize = HEADER_BUF_INITIAL;
    val hdr_res: Result[*u8, allocator.AllocError] = a.alloc[u8](hdr_cap);
    if (hdr_res.is_err()) {
        print.eprintln("mach-lsp: transport: failed to allocate header buffer");
        ret false;
    }
    var hdr_buf: *u8 = hdr_res.unwrap_ok();

    var hdr_len: usize = 0;
    var found_terminator: bool = false;

    for (!found_terminator) {
        val got: Result[usize, str] = reader.read(hdr_buf + hdr_len, 1);
        if (got.is_err()) {
            a.free[u8](hdr_buf, hdr_cap);
            ret false;
        }

        val n: usize = got.unwrap_ok();
        if (n == 0) {
            # EOF
            a.free[u8](hdr_buf, hdr_cap);
            ret false;
        }

        hdr_len = hdr_len + 1;

        # grow header buffer if needed
        if (hdr_len >= hdr_cap) {
            val new_cap: usize = hdr_cap + HEADER_BUF_GROW;
            val grow_res: Result[*u8, allocator.AllocError] = a.resize[u8](hdr_buf, hdr_cap, new_cap);
            if (grow_res.is_err()) {
                a.free[u8](hdr_buf, hdr_cap);
                print.eprintln("mach-lsp: transport: header buffer resize failed");
                ret false;
            }
            hdr_buf = grow_res.unwrap_ok();
            hdr_cap = new_cap;
        }

        # check for \r\n\r\n terminator (standard)
        if (hdr_len >= 4) {
            if (@(hdr_buf + hdr_len - 4) == '\r' &&
                @(hdr_buf + hdr_len - 3) == '\n' &&
                @(hdr_buf + hdr_len - 2) == '\r' &&
                @(hdr_buf + hdr_len - 1) == '\n') {
                found_terminator = true;
            }
        }

        # also tolerate bare \n\n (some clients)
        if (!found_terminator && hdr_len >= 2) {
            if (@(hdr_buf + hdr_len - 2) == '\n' &&
                @(hdr_buf + hdr_len - 1) == '\n') {
                found_terminator = true;
            }
        }
    }

    # --- parse content-length from headers ---

    val content_length: i64 = parse_content_length(hdr_buf, hdr_len);
    a.free[u8](hdr_buf, hdr_cap);

    if (content_length <= 0) {
        print.eprintln("mach-lsp: transport: missing or invalid Content-Length");
        ret false;
    }

    val body_len: usize = content_length::usize;

    # --- read body ---

    val body_res: Result[*u8, allocator.AllocError] = a.alloc[u8](body_len);
    if (body_res.is_err()) {
        print.eprintln("mach-lsp: transport: failed to allocate body buffer");
        ret false;
    }
    val body_buf: *u8 = body_res.unwrap_ok();

    val read_res: Result[usize, str] = stream.read_exact(?reader, body_buf, body_len);
    if (read_res.is_err()) {
        a.free[u8](body_buf, body_len);
        print.eprintln("mach-lsp: transport: failed to read body");
        ret false;
    }

    msg.body = body_buf;
    msg.body_len = body_len;
    ret true;
}

# send_message: write a complete LSP message to stdout.
# ---
# frames the given JSON body with a Content-Length header and writes
# everything to stdout in a single logical operation.
#
# body:     pointer to the JSON payload bytes
# body_len: length of the payload in bytes
# alloc:    allocator for temporary formatting buffers
pub fun send_message(body: &u8, body_len: usize, alloc: allocator.Allocator) {
    if (body == nil || body_len == 0) {
        ret;
    }

    var a: allocator.Allocator = alloc;
    var writer: stream.Writer = stdio.stdout();

    # format the Content-Length digit string
    var digit_buf: [20]u8;
    val digit_len: usize = u64_to_buf(?digit_buf, 20, body_len);
    val digit_start: usize = 20 - digit_len;

    # total frame: "Content-Length: " + digits + "\r\n\r\n" + body
    val prefix_len: usize = HEADER_PREFIX.len;
    val sep_len: usize    = CRLF_CRLF.len;
    val total: usize      = prefix_len + digit_len + sep_len + body_len;

    val buf_res: Result[*u8, allocator.AllocError] = a.alloc[u8](total);
    if (buf_res.is_err()) {
        print.eprintln("mach-lsp: transport: failed to allocate send buffer");
        ret;
    }
    val buf: *u8 = buf_res.unwrap_ok();

    var offset: usize = 0;

    # "Content-Length: "
    mem.raw_copy((buf + offset)::ptr, HEADER_PREFIX.data::ptr, prefix_len);
    offset = offset + prefix_len;

    # digits
    mem.raw_copy((buf + offset)::ptr, (?digit_buf + digit_start)::ptr, digit_len);
    offset = offset + digit_len;

    # "\r\n\r\n"
    mem.raw_copy((buf + offset)::ptr, CRLF_CRLF.data::ptr, sep_len);
    offset = offset + sep_len;

    # JSON body
    mem.raw_copy((buf + offset)::ptr, body::ptr, body_len);

    stream.write_all(?writer, buf, total);

    a.free[u8](buf, total);
}

# send_str: convenience wrapper that sends a str as a complete LSP message.
# ---
# s:     the JSON-RPC response body
# alloc: allocator for temporary buffers
pub fun send_str(s: str, alloc: allocator.Allocator) {
    if (s.data == nil || s.len == 0) {
        ret;
    }
    send_message(s.data, s.len, alloc);
}

# --- internal helpers ---

# parse_content_length: scan header bytes for the Content-Length value.
# ---
# walks the header line by line, looking for a case-insensitive match on
# "content-length". returns the parsed integer value, or -1 on failure.
#
# hdr:     pointer to the raw header bytes
# hdr_len: number of header bytes
# ret:     the content length, or -1 if not found / invalid
fun parse_content_length(hdr: &u8, hdr_len: usize) i64 {
    var line_start: usize = 0;
    var i: usize = 0;

    for (i <= hdr_len) {
        val at_end: bool = (i == hdr_len);
        val is_newline: bool = (!at_end && hdr[i] == '\n');

        if (at_end || is_newline) {
            var line_end: usize = i;

            # strip trailing \r
            if (line_end > line_start && hdr[line_end - 1] == '\r') {
                line_end = line_end - 1;
            }

            val line_len: usize = line_end - line_start;

            if (line_len > 0) {
                # find colon position
                var colon: i64 = -1;
                var j: usize = line_start;
                for (j < line_end) {
                    if (hdr[j] == ':') {
                        colon = j::i64;
                        brk;
                    }
                    j = j + 1;
                }

                if (colon >= 0) {
                    val key_len: usize = (colon::usize) - line_start;

                    if (key_len == CL_KEY_LEN) {
                        var match: bool = true;
                        var k: usize = 0;
                        for (k < key_len) {
                            var ch: u8 = hdr[line_start + k];
                            # lowercase for case-insensitive comparison
                            if (ch >= 'A' && ch <= 'Z') {
                                ch = ch + 32;
                            }
                            if (ch != CL_KEY.data[k]) {
                                match = false;
                                brk;
                            }
                            k = k + 1;
                        }

                        if (match) {
                            # skip colon and whitespace
                            var val_start: usize = (colon::usize) + 1;
                            for (val_start < line_end) {
                                val c: u8 = hdr[val_start];
                                if (c != ' ' && c != '\t') {
                                    brk;
                                }
                                val_start = val_start + 1;
                            }

                            # parse decimal digits
                            var result: i64 = 0;
                            var valid: bool = false;
                            var d: usize = val_start;
                            for (d < line_end) {
                                val digit: u8 = hdr[d];
                                if (digit >= '0' && digit <= '9') {
                                    result = result * 10 + ((digit - '0')::i64);
                                    valid = true;
                                }
                                or {
                                    brk;
                                }
                                d = d + 1;
                            }

                            if (valid) {
                                ret result;
                            }
                        }
                    }
                }
            }

            line_start = i + 1;
        }

        i = i + 1;
    }

    ret -1;
}

# u64_to_buf: render an unsigned integer into a byte buffer (right-aligned).
# ---
# writes decimal digits into the end of the provided buffer. returns the
# number of digits written. the caller should read from offset (buf_cap - result).
#
# buf:     pointer to the output buffer
# buf_cap: capacity of the buffer in bytes
# value:   the value to render
# ret:     number of digit bytes written
fun u64_to_buf(buf: *u8, buf_cap: usize, value: usize) usize {
    if (value == 0) {
        @(buf + buf_cap - 1) = '0';
        ret 1;
    }

    var v: usize = value;
    var pos: usize = buf_cap;

    for (v > 0 && pos > 0) {
        pos = pos - 1;
        val rem: usize = v % 10;
        @(buf + pos) = ('0' + rem)::u8;
        v = v / 10;
    }

    ret buf_cap - pos;
}

# --- tests ---

test "transport: parse_content_length extracts value from standard header" {
    val hdr: str = "Content-Length: 42\r\n\r\n";
    val result: i64 = parse_content_length(hdr.data, hdr.len);
    if (result != 42) { ret 0; }
    ret 1;
}

test "transport: parse_content_length is case-insensitive" {
    val hdr: str = "content-length: 100\r\n\r\n";
    val result: i64 = parse_content_length(hdr.data, hdr.len);
    if (result != 100) { ret 0; }
    ret 1;
}

test "transport: parse_content_length handles mixed case" {
    val hdr: str = "Content-LENGTH: 7\r\n\r\n";
    val result: i64 = parse_content_length(hdr.data, hdr.len);
    if (result != 7) { ret 0; }
    ret 1;
}

test "transport: parse_content_length handles large value" {
    val hdr: str = "Content-Length: 999999\r\n\r\n";
    val result: i64 = parse_content_length(hdr.data, hdr.len);
    if (result != 999999) { ret 0; }
    ret 1;
}

test "transport: parse_content_length ignores other headers" {
    val hdr: str = "Content-Type: application/json\r\nContent-Length: 55\r\n\r\n";
    val result: i64 = parse_content_length(hdr.data, hdr.len);
    if (result != 55) { ret 0; }
    ret 1;
}

test "transport: parse_content_length returns -1 for missing header" {
    val hdr: str = "Content-Type: application/json\r\n\r\n";
    val result: i64 = parse_content_length(hdr.data, hdr.len);
    if (result != -1) { ret 0; }
    ret 1;
}

test "transport: parse_content_length returns -1 for empty header" {
    val hdr: str = "\r\n\r\n";
    val result: i64 = parse_content_length(hdr.data, hdr.len);
    if (result != -1) { ret 0; }
    ret 1;
}

test "transport: parse_content_length handles bare LF line endings" {
    val hdr: str = "Content-Length: 10\n\n";
    val result: i64 = parse_content_length(hdr.data, hdr.len);
    if (result != 10) { ret 0; }
    ret 1;
}

test "transport: parse_content_length skips whitespace after colon" {
    val hdr: str = "Content-Length:   \t  77\r\n\r\n";
    val result: i64 = parse_content_length(hdr.data, hdr.len);
    if (result != 77) { ret 0; }
    ret 1;
}

test "transport: parse_content_length returns -1 for non-numeric value" {
    val hdr: str = "Content-Length: abc\r\n\r\n";
    val result: i64 = parse_content_length(hdr.data, hdr.len);
    if (result != -1) { ret 0; }
    ret 1;
}

test "transport: parse_content_length stops parsing at non-digit" {
    val hdr: str = "Content-Length: 123xyz\r\n\r\n";
    val result: i64 = parse_content_length(hdr.data, hdr.len);
    if (result != 123) { ret 0; }
    ret 1;
}

test "transport: u64_to_buf renders zero" {
    var buf: [20]u8;
    val len: usize = u64_to_buf(?buf, 20, 0);
    if (len != 1) { ret 0; }
    if (buf[19] != '0') { ret 0; }
    ret 1;
}

test "transport: u64_to_buf renders single digit" {
    var buf: [20]u8;
    val len: usize = u64_to_buf(?buf, 20, 7);
    if (len != 1) { ret 0; }
    if (buf[19] != '7') { ret 0; }
    ret 1;
}

test "transport: u64_to_buf renders multi-digit number" {
    var buf: [20]u8;
    val len: usize = u64_to_buf(?buf, 20, 42);
    if (len != 2) { ret 0; }
    if (buf[18] != '4') { ret 0; }
    if (buf[19] != '2') { ret 0; }
    ret 1;
}

test "transport: u64_to_buf renders large number" {
    var buf: [20]u8;
    val len: usize = u64_to_buf(?buf, 20, 1000000);
    if (len != 7) { ret 0; }
    if (buf[13] != '1') { ret 0; }
    if (buf[14] != '0') { ret 0; }
    if (buf[19] != '0') { ret 0; }
    ret 1;
}

test "transport: u64_to_buf renders 10 correctly" {
    var buf: [20]u8;
    val len: usize = u64_to_buf(?buf, 20, 10);
    if (len != 2) { ret 0; }
    if (buf[18] != '1') { ret 0; }
    if (buf[19] != '0') { ret 0; }
    ret 1;
}

test "transport: u64_to_buf renders powers of ten" {
    var buf: [20]u8;

    val len1: usize = u64_to_buf(?buf, 20, 1);
    if (len1 != 1) { ret 0; }
    if (buf[19] != '1') { ret 0; }

    val len2: usize = u64_to_buf(?buf, 20, 100);
    if (len2 != 3) { ret 0; }
    if (buf[17] != '1') { ret 0; }
    if (buf[18] != '0') { ret 0; }
    if (buf[19] != '0') { ret 0; }

    val len3: usize = u64_to_buf(?buf, 20, 10000);
    if (len3 != 5) { ret 0; }
    if (buf[15] != '1') { ret 0; }
    if (buf[19] != '0') { ret 0; }

    ret 1;
}

test "transport: u64_to_buf digit string matches expected" {
    # verify that 12345 renders as "12345"
    var buf: [20]u8;
    val len: usize = u64_to_buf(?buf, 20, 12345);
    if (len != 5) { ret 0; }
    val start: usize = 20 - len;
    if (buf[start]     != '1') { ret 0; }
    if (buf[start + 1] != '2') { ret 0; }
    if (buf[start + 2] != '3') { ret 0; }
    if (buf[start + 3] != '4') { ret 0; }
    if (buf[start + 4] != '5') { ret 0; }
    ret 1;
}
