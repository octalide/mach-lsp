use std.io.console;
use std.system.memory;
use std.text.parse;
use std.types.bool;
use std.types.string;

use util;

# scan the header block to locate a content-length value
fun parse_content_length(header: []u8) i64 {
    var line_start: u64 = 0;
    var i: u64 = 0;

    for (i <= header.length) {
        if (i == header.length || header[i] == '\n') {
            var line_len: u64 = 0;
            if (i > line_start) {
                line_len = i - line_start;
                if (line_len > 0 && header[line_start + line_len - 1] == '\r') {
                    line_len = line_len - 1;
                }
            }

            if (line_len > 0) {
                val line: []u8 = []u8{ header.data + line_start, line_len };

                var colon_pos: i64 = -1;
                var j: u64 = 0;
                for (j < line.length) {
                    if (line[j] == ':') {
                        colon_pos = j::i64;
                        brk;
                    }

                    j = j + 1;
                }

                if (colon_pos >= 0) {
                    val key_slice: []u8 = []u8{ line.data, colon_pos::u64 };
                    var k: u64 = 0;
                    var is_content_length: bool = true;
                    val expected: []u8 = "content-length";

                    if (key_slice.length != expected.length) {
                        is_content_length = false;
                    }
                    or {
                        for (k < expected.length) {
                            var ch: u8 = key_slice[k];
                            if (ch >= 'A' && ch <= 'Z') {
                                ch = ch + 32;
                            }

                            if (ch != expected[k]) {
                                is_content_length = false;
                                brk;
                            }

                            k = k + 1;
                        }
                    }

                    if (is_content_length) {
                        var value_start: u64 = (colon_pos::u64) + 1;

                        for (value_start < line.length) {
                            val ch: u8 = line[value_start];
                            if (ch == ' ' || ch == '\t') {
                                value_start = value_start + 1;
                            }
                            or {
                                brk;
                            }
                        }

                        if (value_start >= line.length) {
                            ret -1;
                        }

                        var value_end: u64 = value_start;
                        for (value_end < line.length) {
                            val ch: u8 = line[value_end];
                            if (ch >= '0' && ch <= '9') {
                                value_end = value_end + 1;
                            }
                            or {
                                brk;
                            }
                        }

                        if (value_end == value_start) {
                            ret -1;
                        }

                        val digits: []u8 = []u8{ line.data + value_start, value_end - value_start };
                        val result: u64 = parse_u64_dec(digits);
                        ret result::i64;
                    }
                }
            }

            line_start = i + 1;
        }

        i = i + 1;
    }

    ret -1;
}

pub fun read_message() []u8 {
    var header_cap: u64 = 256;
    var header_buf: *u8 = allocate(header_cap);
    if (header_buf == nil) {
        ret []u8{ nil, 0 };
    }

    var header_len: u64 = 0;
    # read one byte at a time until header terminator is seen
    for {
        val got: i64 = read(STDIN, header_buf + header_len, 1);
        if (got <= 0) {
            deallocate(header_buf, header_cap);
            if (header_len == 0) {
                ret []u8{ nil, 0 };
            }

            write(STDERR, "error: failed to read header\n");
            ret []u8{ nil, 0 };
        }

        header_len = header_len + 1;

        if (header_len >= header_cap) {
            val new_cap: u64 = header_cap + 256;
            val new_buf: *u8 = reallocate(header_buf, header_cap, new_cap);
            if (new_buf == nil) {
                deallocate(header_buf, header_cap);
                ret []u8{ nil, 0 };
            }

            header_buf = new_buf;
            header_cap = new_cap;
        }

        # detect standard crlf-crlf terminator
        if (header_len >= 4) {
            val a: u8 = @(header_buf + header_len - 4);
            val b: u8 = @(header_buf + header_len - 3);
            val c: u8 = @(header_buf + header_len - 2);
            val d: u8 = @(header_buf + header_len - 1);
            if (a == '\r' && b == '\n' && c == '\r' && d == '\n') {
                brk;
            }
        }

        # tolerate bare lf separators
        if (header_len >= 2) {
            val x: u8 = @(header_buf + header_len - 2);
            val y: u8 = @(header_buf + header_len - 1);
            if (x == '\n' && y == '\n') {
                brk;
            }
        }

        # also handle bare cr separators used by some clients
        if (header_len >= 2) {
            val m: u8 = @(header_buf + header_len - 2);
            val n: u8 = @(header_buf + header_len - 1);
            if (m == '\r' && n == '\r') {
                brk;
            }
        }
    }

    val header_slice: []u8 = []u8{ header_buf, header_len };
    val body_len_i64: i64 = parse_content_length(header_slice);
    deallocate(header_buf, header_cap);

    if (body_len_i64 <= 0) {
        write(STDERR, "error: invalid content length\n");
        ret []u8{ nil, 0 };
    }

    val body_len: u64 = body_len_i64::u64;
    if (body_len == 0) {
        write(STDERR, "error: zero content length\n");
        ret []u8{ nil, 0 };
    }

    # grab an exact buffer for the incoming body
    val body_buf: *u8 = allocate(body_len);
    if (body_buf == nil) {
        write(STDERR, "error: failed to allocate body\n");
        ret []u8{ nil, 0 };
    }

    var received: u64 = 0;
    for (received < body_len) {
        val chunk: i64 = read(STDIN, body_buf + received, (body_len - received));
        if (chunk <= 0) {
            deallocate(body_buf, body_len);
            write(STDERR, "error: failed to read body\n");
            ret []u8{ nil, 0 };
        }

        received = received + (chunk::u64);
    }

    val body_slice: []u8 = []u8{ body_buf, body_len };
    ret body_slice;
}

pub fun send_message(body: []u8) {
    val prefix: []u8 = "Content-Length: ";
    val suffix: []u8 = "\r\n\r\n";

    val len_str: []u8 = u64_to_string(body.length);
    var length_digits: []u8 = "0";
    if (len_str.data != nil && len_str.length > 0) {
        length_digits = len_str;
    }

    val header_len: u64 = prefix.length + length_digits.length + suffix.length;
    val header_buf: *u8 = allocate(header_len);
    if (header_buf == nil) {
        slice_free(len_str);
        ret;
    }

    var offset: u64 = 0;
    memory_copy(header_buf + offset, prefix.data, prefix.length);
    offset = offset + prefix.length;
    memory_copy(header_buf + offset, length_digits.data, length_digits.length);
    offset = offset + length_digits.length;
    memory_copy(header_buf + offset, suffix.data, suffix.length);

    val header_view: string = string{ header_buf, header_len };
    write(STDOUT, header_view);
    deallocate(header_buf, header_len);

    if (body.data != nil && body.length > 0) {
        val body_view: string = string{ body.data, body.length };
        write(STDOUT, body_view);
    }

    slice_free(len_str);
}
