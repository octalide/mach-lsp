use std.system.memory;
use std.types.bool;

pub fun slice_free(s: []u8) {
    if (s.data == nil || s.capacity == 0) {
        ret;
    }

    deallocate(s.data, s.capacity);
}

pub fun clone_slice(src: []u8) []u8 {
    if (src.capacity == 0) {
        ret []u8{ nil, 0 };
    }

    val buf: *u8 = allocate(src.capacity);
    if (buf == nil) {
        ret []u8{ nil, 0 };
    }

    memory_copy(buf, src.data, src.capacity);
    ret []u8{ buf, src.capacity };
}

pub fun slice_equals(a: []u8, b: []u8) bool {
    if (a.capacity != b.capacity) {
        ret false;
    }

    var i: u64 = 0;
    for (i < a.capacity) {
        if (a[i] != b[i]) {
            ret false;
        }

        i = i + 1;
    }

    ret true;
}

pub fun find_subslice(data: []u8, pattern: []u8) i64 {
    if (pattern.capacity == 0) {
        ret 0;
    }

    if (pattern.capacity > data.capacity) {
        ret -1;
    }

    var i: u64 = 0;
    val limit: u64 = data.capacity - pattern.capacity;
    for (i <= limit) {
        var j: u64 = 0;
        var match: bool = true;
        for (j < pattern.capacity) {
            if (data[i + j] != pattern[j]) {
                match = false;
                brk;
            }

            j = j + 1;
        }

        if (match) {
            ret i::i64;
        }

        i = i + 1;
    }

    ret -1;
}

pub fun u64_to_string(value: u64) []u8 {
    val cap: u64 = 32;
    val tmp: *u8 = allocate(cap);
    if (tmp == nil) {
        ret []u8{ nil, 0 };
    }

    val buf: *u8 = allocate(cap);
    if (buf == nil) {
        deallocate(tmp, cap);
        ret []u8{ nil, 0 };
    }

    if (value == 0) {
        @(buf) = '0';
        deallocate(tmp, cap);
        ret []u8{ buf, 1 };
    }

    var len: u64 = 0;
    var v: u64 = value;
    for (v > 0) {
        val rem: u64 = v % 10;
        @(tmp + len) = ('0' + rem)::u8;
        len = len + 1;
        v = v / 10;
    }

    var i: u64 = 0;
    for (i < len) {
        val ch: u8 = @(tmp + (len - 1 - i));
        @(buf + i) = ch;
        i = i + 1;
    }

    deallocate(tmp, cap);
    ret []u8{ buf, len };
}

pub str SliceBuilder {
    data: *u8;
    length: u64;
    capacity: u64;
}

pub fun slice_builder_init(builder: *SliceBuilder) {
    builder.data = nil;
    builder.capacity = 0;
    builder.capacity = 0;
}

fun slice_builder_reserve(builder: *SliceBuilder, needed: u64) bool {
    if (needed <= builder.capacity) {
        ret true;
    }

    var new_cap: u64 = builder.capacity;
    if (new_cap == 0) {
        new_cap = 128;
    }

    for (new_cap < needed) {
        new_cap = new_cap + (new_cap >> 1) + 32;
    }

    var new_data: *u8 = nil;
    if (builder.data == nil) {
        new_data = allocate(new_cap);
    }
    or {
        new_data = reallocate(builder.data, builder.capacity, new_cap);
    }

    if (new_data == nil) {
        ret false;
    }

    builder.data = new_data;
    builder.capacity = new_cap;
    ret true;
}

pub fun slice_builder_append(builder: *SliceBuilder, value: []u8) bool {
    if (value.data == nil || value.capacity == 0) {
        ret true;
    }

    val required: u64 = builder.capacity + value.capacity;
    if (slice_builder_reserve(builder, required) == false) {
        ret false;
    }

    memory_copy(builder.data + builder.capacity, value.data, value.capacity);
    builder.capacity = required;
    ret true;
}

pub fun slice_builder_append_byte(builder: *SliceBuilder, value: u8) bool {
    val required: u64 = builder.capacity + 1;
    if (slice_builder_reserve(builder, required) == false) {
        ret false;
    }

    @(builder.data + builder.capacity) = value;
    builder.capacity = required;
    ret true;
}

pub fun slice_builder_finish(builder: *SliceBuilder) []u8 {
    if (builder.capacity == 0) {
        if (builder.data != nil && builder.capacity != 0) {
            deallocate(builder.data, builder.capacity);
        }

        builder.data = nil;
        builder.capacity = 0;
        ret []u8{ nil, 0 };
    }

    if (builder.capacity > builder.capacity) {
        val shrunk: *u8 = reallocate(builder.data, builder.capacity, builder.capacity);
        if (shrunk != nil) {
            builder.data = shrunk;
            builder.capacity = builder.capacity;
        }
    }

    val out: []u8 = []u8{ builder.data, builder.capacity };
    builder.data = nil;
    builder.capacity = 0;
    builder.capacity = 0;
    ret out;
}

pub fun slice_builder_dnit(builder: *SliceBuilder) {
    if (builder.data != nil && builder.capacity != 0) {
        deallocate(builder.data, builder.capacity);
    }

    builder.data = nil;
    builder.capacity = 0;
    builder.capacity = 0;
}
