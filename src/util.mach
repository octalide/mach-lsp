use std.system.memory;
use std.types.bool;

pub fun slice_free(s: []u8) {
    if (s.data == nil || s.length == 0) {
        ret;
    }

    deallocate(s.data, s.length);
}

pub fun clone_slice(src: []u8) []u8 {
    if (src.length == 0) {
        ret []u8{ nil, 0 };
    }

    val buf: *u8 = allocate(src.length);
    if (buf == nil) {
        ret []u8{ nil, 0 };
    }

    memory_copy(buf, src.data, src.length);
    ret []u8{ buf, src.length };
}

pub fun slice_equals(a: []u8, b: []u8) bool {
    if (a.length != b.length) {
        ret false;
    }

    var i: u64 = 0;
    for (i < a.length) {
        if (a[i] != b[i]) {
            ret false;
        }

        i = i + 1;
    }

    ret true;
}

pub fun find_subslice(data: []u8, pattern: []u8) i64 {
    if (pattern.length == 0) {
        ret 0;
    }

    if (pattern.length > data.length) {
        ret -1;
    }

    var i: u64 = 0;
    val limit: u64 = data.length - pattern.length;
    for (i <= limit) {
        var j: u64 = 0;
        var match: bool = true;
        for (j < pattern.length) {
            if (data[i + j] != pattern[j]) {
                match = false;
                brk;
            }

            j = j + 1;
        }

        if (match) {
            ret i::i64;
        }

        i = i + 1;
    }

    ret -1;
}

pub fun u64_to_string(value: u64) []u8 {
    val cap: u64 = 32;
    val tmp: *u8 = allocate(cap);
    if (tmp == nil) {
        ret []u8{ nil, 0 };
    }

    val buf: *u8 = allocate(cap);
    if (buf == nil) {
        deallocate(tmp, cap);
        ret []u8{ nil, 0 };
    }

    if (value == 0) {
        @(buf) = '0';
        deallocate(tmp, cap);
        ret []u8{ buf, 1 };
    }

    var len: u64 = 0;
    var v: u64 = value;
    for (v > 0) {
        val rem: u64 = v % 10;
        @(tmp + len) = ('0' + rem)::u8;
        len = len + 1;
        v = v / 10;
    }

    var i: u64 = 0;
    for (i < len) {
        val ch: u8 = @(tmp + (len - 1 - i));
        @(buf + i) = ch;
        i = i + 1;
    }

    deallocate(tmp, cap);
    ret []u8{ buf, len };
}

pub str SliceBuilder {
    data: *u8;
    length: u64;
    capacity: u64;
}

pub fun slice_builder_init(builder: *SliceBuilder) {
    builder->data = nil;
    builder->length = 0;
    builder->capacity = 0;
}

fun slice_builder_reserve(builder: *SliceBuilder, needed: u64) bool {
    if (needed <= builder->capacity) {
        ret true;
    }

    var new_cap: u64 = builder->capacity;
    if (new_cap == 0) {
        new_cap = 128;
    }

    for (new_cap < needed) {
        new_cap = new_cap + (new_cap >> 1) + 32;
    }

    var new_data: *u8 = nil;
    if (builder->data == nil) {
        new_data = allocate(new_cap);
    }
    or {
        new_data = reallocate(builder->data, builder->capacity, new_cap);
    }

    if (new_data == nil) {
        ret false;
    }

    builder->data = new_data;
    builder->capacity = new_cap;
    ret true;
}

pub fun slice_builder_append(builder: *SliceBuilder, value: []u8) bool {
    if (value.data == nil || value.length == 0) {
        ret true;
    }

    val required: u64 = builder->length + value.length;
    if (slice_builder_reserve(builder, required) == false) {
        ret false;
    }

    memory_copy(builder->data + builder->length, value.data, value.length);
    builder->length = required;
    ret true;
}

pub fun slice_builder_append_byte(builder: *SliceBuilder, value: u8) bool {
    val required: u64 = builder->length + 1;
    if (slice_builder_reserve(builder, required) == false) {
        ret false;
    }

    @(builder->data + builder->length) = value;
    builder->length = required;
    ret true;
}

pub fun slice_builder_finish(builder: *SliceBuilder) []u8 {
    if (builder->length == 0) {
        if (builder->data != nil && builder->capacity != 0) {
            deallocate(builder->data, builder->capacity);
        }

        builder->data = nil;
        builder->capacity = 0;
        ret []u8{ nil, 0 };
    }

    if (builder->capacity > builder->length) {
        val shrunk: *u8 = reallocate(builder->data, builder->capacity, builder->length);
        if (shrunk != nil) {
            builder->data = shrunk;
            builder->capacity = builder->length;
        }
    }

    val out: []u8 = []u8{ builder->data, builder->length };
    builder->data = nil;
    builder->length = 0;
    builder->capacity = 0;
    ret out;
}

pub fun slice_builder_dnit(builder: *SliceBuilder) {
    if (builder->data != nil && builder->capacity != 0) {
        deallocate(builder->data, builder->capacity);
    }

    builder->data = nil;
    builder->length = 0;
    builder->capacity = 0;
}
