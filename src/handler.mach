use std.types.bool;
use std.types.size;
use std.types.string;
use std.types.result;

use allocator: std.allocator;
use mem:       std.memory;
use print:     std.print;

use transport: mach_lsp.transport;
use workspace: mach_lsp.workspace;
use json:      mach_lsp.json;

# forward declaration — Server lives in mach_lsp.server but we receive *Server
# from dispatch. to avoid a circular import we accept ptr and cast internally.
# (the server module imports us; we must not import it back.)
use server:      mach_lsp.server;
use diagnostics: mach_lsp.diagnostics;

# mach_lsp.handler: LSP request/notification handler implementations.
# ---
# each public handle_* function corresponds to a single LSP method.
# helper functions build JSON-RPC responses and send them via the transport.

# ============================================================================
# Response construction helpers
# ============================================================================

# send_error: send a JSON-RPC error response.
# ---
# srv:     pointer to the server (used for the allocator)
# id:      raw JSON id value (numeric string or quoted string — already formatted)
# code:    LSP/JSON-RPC error code
# message: human-readable error message
pub fun send_error(srv: *server.Server, id: str, code: i64, message: str) {
    var a: allocator.Allocator = srv.alloc;

    val quoted_msg: str = json.quote(message, a);

    val code_str: str = format_i64(code, a);

    # {"jsonrpc":"2.0","id":<id>,"error":{"code":<code>,"message":<msg>}}
    val prefix:  str = "{\"jsonrpc\":\"2.0\",\"id\":";
    val mid1:    str = ",\"error\":{\"code\":";
    val mid2:    str = ",\"message\":";
    val suffix:  str = "}}";

    val total: usize = prefix.len + id.len + mid1.len + code_str.len +
                       mid2.len + quoted_msg.len + suffix.len;

    val buf_res: Result[*u8, allocator.AllocError] = a.alloc[u8](total);
    if (buf_res.is_err()) {
        ret;
    }
    val buf: *u8 = buf_res.unwrap_ok();

    var off: usize = 0;
    off = append(buf, off, prefix);
    off = append(buf, off, id);
    off = append(buf, off, mid1);
    off = append(buf, off, code_str);
    off = append(buf, off, mid2);
    off = append(buf, off, quoted_msg);
    off = append(buf, off, suffix);

    transport.send_message(buf, total, a);

    a.free[u8](buf, total);
    free_str(quoted_msg, a);
    free_str(code_str, a);
}

# send_result: send a JSON-RPC success response with an arbitrary result fragment.
# ---
# srv:    pointer to the server
# id:     raw JSON id token
# result: pre-formatted JSON result value
fun send_result(srv: *server.Server, id: str, result: str) {
    var a: allocator.Allocator = srv.alloc;

    val prefix: str = "{\"jsonrpc\":\"2.0\",\"id\":";
    val mid:    str = ",\"result\":";
    val suffix: str = "}";

    val total: usize = prefix.len + id.len + mid.len + result.len + suffix.len;

    val buf_res: Result[*u8, allocator.AllocError] = a.alloc[u8](total);
    if (buf_res.is_err()) {
        ret;
    }
    val buf: *u8 = buf_res.unwrap_ok();

    var off: usize = 0;
    off = append(buf, off, prefix);
    off = append(buf, off, id);
    off = append(buf, off, mid);
    off = append(buf, off, result);
    off = append(buf, off, suffix);

    transport.send_message(buf, total, a);
    a.free[u8](buf, total);
}

# send_null_result: send a JSON-RPC response with result: null.
fun send_null_result(srv: *server.Server, id: str) {
    send_result(srv, id, "null");
}

# ============================================================================
# Lifecycle handlers
# ============================================================================

# handle_initialize: respond to the `initialize` request.
# ---
# advertises server capabilities and transitions to the RUNNING state.
pub fun handle_initialize(srv: *server.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);

    if (id.len == 0) {
        print.eprintln("mach-lsp: initialize: missing id");
        ret;
    }

    srv.status = server.STATUS_RUNNING;

    # capabilities we advertise:
    #   textDocumentSync: full (1) — client sends entire document on change
    #   hoverProvider: true
    #   definitionProvider: true
    #   completionProvider: {} (defaults)
    #   documentSymbolProvider: true
    val capabilities: str = "{\"capabilities\":{\"textDocumentSync\":1,\"hoverProvider\":true,\"definitionProvider\":true,\"completionProvider\":{},\"documentSymbolProvider\":true},\"serverInfo\":{\"name\":\"mach-lsp\",\"version\":\"0.1.0\"}}";

    send_result(srv, id, capabilities);
}

# handle_shutdown: respond to the `shutdown` request.
# ---
# returns null and marks the server as shutting down.
pub fun handle_shutdown(srv: *server.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);

    srv.status = server.STATUS_SHUTTING_DOWN;

    if (id.len > 0) {
        send_null_result(srv, id);
    }
}

# handle_exit: process the `exit` notification.
# ---
# terminates the message loop. exit code is 0 if shutdown was requested first,
# 1 otherwise (per LSP spec).
pub fun handle_exit(srv: *server.Server) {
    if (srv.status != server.STATUS_SHUTTING_DOWN) {
        srv.exit_code = 1;
    }
    srv.status = server.STATUS_EXITED;
}

# ============================================================================
# Document synchronization
# ============================================================================

# handle_did_open: process `textDocument/didOpen` notification.
# ---
# registers the document in the workspace with its initial text.
pub fun handle_did_open(srv: *server.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val anchor: str = "\"textDocument\"";

    val uri: str = json.extract_after(body, anchor, "\"uri\"", a);
    val text: str = json.extract_after(body, anchor, "\"text\"", a);

    if (uri.len > 0) {
        val doc: *workspace.Document = workspace.open(?srv.ws, uri.data, uri.len, text.data, text.len);
        if (doc != nil) {
            diagnostics.publish_diagnostics(doc, a);
        }
    }

    free_str(uri, a);
    free_str(text, a);
}

# handle_did_change: process `textDocument/didChange` notification.
# ---
# with textDocumentSync = 1 (full), the entire new text is in the first
# content change entry. we extract it and update the workspace copy.
pub fun handle_did_change(srv: *server.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val anchor: str = "\"textDocument\"";

    val uri: str = json.extract_after(body, anchor, "\"uri\"", a);

    # the new full text lives under "contentChanges"[0]."text"
    val text_anchor: str = "\"contentChanges\"";
    val text: str = json.extract_after(body, text_anchor, "\"text\"", a);

    if (uri.len > 0) {
        val doc: *workspace.Document = workspace.find(?srv.ws, uri.data, uri.len);
        if (doc != nil) {
            workspace.update(?srv.ws, doc, text.data, text.len);
            diagnostics.publish_diagnostics(doc, a);
        }
    }

    free_str(uri, a);
    free_str(text, a);
}

# handle_did_close: process `textDocument/didClose` notification.
# ---
# removes the document from the workspace.
pub fun handle_did_close(srv: *server.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val anchor: str = "\"textDocument\"";

    val uri: str = json.extract_after(body, anchor, "\"uri\"", a);
    if (uri.len > 0) {
        # clear diagnostics before removing the document from the workspace
        val doc: *workspace.Document = workspace.find(?srv.ws, uri.data, uri.len);
        if (doc != nil) {
            diagnostics.clear_diagnostics(doc, a);
        }
        workspace.close(?srv.ws, uri.data, uri.len);
    }

    free_str(uri, a);
}

# ============================================================================
# Language features (stubs)
# ============================================================================

# handle_hover: respond to `textDocument/hover`.
# ---
# TODO: hook into mach.compiler.sema for real type information.
# currently returns a placeholder message with the document byte size.
pub fun handle_hover(srv: *server.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);
    if (id.len == 0) {
        ret;
    }

    val anchor: str = "\"textDocument\"";
    val uri: str = json.extract_after(body, anchor, "\"uri\"", a);
    if (uri.len == 0) {
        send_null_result(srv, id);
        free_str(uri, a);
        ret;
    }

    val doc: *workspace.Document = workspace.find(?srv.ws, uri.data, uri.len);
    if (doc == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        ret;
    }

    # build hover content — placeholder showing document size
    val size_str: str = json.format_usize(doc.text_len, a);
    val hover_prefix: str = "mach-lsp: document bytes = ";

    val msg_len: usize = hover_prefix.len + size_str.len;
    val msg_res: Result[*u8, allocator.AllocError] = a.alloc[u8](msg_len);
    if (msg_res.is_err()) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(size_str, a);
        ret;
    }
    val msg_buf: *u8 = msg_res.unwrap_ok();
    mem.raw_copy(msg_buf::ptr, hover_prefix.data::ptr, hover_prefix.len);
    mem.raw_copy((msg_buf + hover_prefix.len)::ptr, size_str.data::ptr, size_str.len);
    val msg: str = str{ data: msg_buf, len: msg_len };

    val quoted_msg: str = json.quote(msg, a);

    # {"contents":{"kind":"markdown","value":<quoted>}}
    val r_prefix: str = "{\"contents\":{\"kind\":\"markdown\",\"value\":";
    val r_suffix: str = "}}";

    val result_len: usize = r_prefix.len + quoted_msg.len + r_suffix.len;
    val result_res: Result[*u8, allocator.AllocError] = a.alloc[u8](result_len);
    if (result_res.is_err()) {
        send_null_result(srv, id);
    }
    or {
        val result_buf: *u8 = result_res.unwrap_ok();
        var off: usize = 0;
        off = append(result_buf, off, r_prefix);
        off = append(result_buf, off, quoted_msg);
        off = append(result_buf, off, r_suffix);

        val result: str = str{ data: result_buf, len: result_len };
        send_result(srv, id, result);
        a.free[u8](result_buf, result_len);
    }

    a.free[u8](msg_buf, msg_len);
    free_str(quoted_msg, a);
    free_str(size_str, a);
    free_str(uri, a);
}

# handle_definition: respond to `textDocument/definition`.
# ---
# TODO: hook into mach.compiler.sema symbol table for real go-to-definition.
# currently returns null (no result).
pub fun handle_definition(srv: *server.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);
    if (id.len > 0) {
        send_null_result(srv, id);
    }
}

# handle_completion: respond to `textDocument/completion`.
# ---
# TODO: hook into mach.compiler.sema for real symbol completion.
# currently returns an empty completion list.
pub fun handle_completion(srv: *server.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);
    if (id.len > 0) {
        send_result(srv, id, "[]");
    }
}

# handle_document_symbol: respond to `textDocument/documentSymbol`.
# ---
# TODO: hook into mach.compiler.parser / ast for real symbol extraction.
# currently returns an empty symbol list.
pub fun handle_document_symbol(srv: *server.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);
    if (id.len > 0) {
        send_result(srv, id, "[]");
    }
}

# ============================================================================
# Internal utilities
# ============================================================================

# append: copy a str into buf at the given offset and return the new offset.
fun append(buf: *u8, offset: usize, s: str) usize {
    if (s.data != nil && s.len > 0) {
        mem.raw_copy((buf + offset)::ptr, s.data::ptr, s.len);
    }
    ret offset + s.len;
}

# free_str: free a heap-allocated str produced by json extraction/quoting.
fun free_str(s: str, alloc: allocator.Allocator) {
    if (s.data != nil && s.len > 0) {
        var a: allocator.Allocator = alloc;
        a.free[u8](s.data, s.len);
    }
}

# format_i64: render a signed 64-bit integer as a decimal digit string.
# ---
# the returned str is heap-allocated via alloc.
fun format_i64(value: i64, alloc: allocator.Allocator) str {
    var tmp: [21]u8;
    var pos: usize = 21;
    var negative: bool = false;
    var v: i64 = value;

    if (v < 0) {
        negative = true;
        v = -v;
    }

    if (v == 0) {
        pos = pos - 1;
        tmp[pos] = '0';
    }
    or {
        for (v > 0 && pos > 0) {
            pos = pos - 1;
            val rem: i64 = v % 10;
            tmp[pos] = ('0' + rem)::u8;
            v = v / 10;
        }
    }

    if (negative && pos > 0) {
        pos = pos - 1;
        tmp[pos] = '-';
    }

    val len: usize = 21 - pos;
    var a: allocator.Allocator = alloc;
    val res: Result[*u8, allocator.AllocError] = a.alloc[u8](len);
    if (res.is_err()) {
        ret str{ data: nil, len: 0 };
    }
    val buf: *u8 = res.unwrap_ok();
    mem.raw_copy(buf::ptr, (?tmp[pos])::ptr, len);

    ret str{ data: buf, len: len };
}
