use std.types.bool;
use std.types.size;
use std.types.string;
use std.types.result;

use allocator: std.allocator;
use mem:       std.memory;
use print:     std.print;

use transport: mls.transport;
use workspace: mls.workspace;
use json:      mls.json;

use ast:    mach.compiler.ast;
use symbol: mach.compiler.symbol;
use token:  mach.compiler.token;

use lsp_types:   mls.lsp_types;
use diagnostics: mls.diagnostics;
use analysis:    mls.analysis;

# mls.handler: LSP request/notification handler implementations.

# ============================================================================
# response construction helpers
# ============================================================================

pub fun send_error(srv: *lsp_types.Server, id: str, code: i64, message: str) {
    var a: allocator.Allocator = srv.alloc;

    val quoted_msg: str = json.quote(message, a);
    val code_str: str = json.format_i64(code, a);

    val prefix:  str = "{\"jsonrpc\":\"2.0\",\"id\":";
    val mid1:    str = ",\"error\":{\"code\":";
    val mid2:    str = ",\"message\":";
    val suffix:  str = "}}";

    val id_len: usize = str_len(id);
    val quoted_msg_len: usize = str_len(quoted_msg);
    val code_str_len: usize = str_len(code_str);

    val total: usize = str_len(prefix) + id_len + str_len(mid1) + code_str_len +
                       str_len(mid2) + quoted_msg_len + str_len(suffix);

    val buf_res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, total + 1);
    if (!buf_res.tag) {
        free_str(quoted_msg, a);
        free_str(code_str, a);
        ret;
    }
    val buf: *u8 = buf_res.value.ok;

    var off: usize = 0;
    off = append(buf, off, prefix);
    off = append(buf, off, id);
    off = append(buf, off, mid1);
    off = append(buf, off, code_str);
    off = append(buf, off, mid2);
    off = append(buf, off, quoted_msg);
    off = append(buf, off, suffix);
    buf[off] = 0;

    transport.send_message(buf::str, a);

    allocator.allocator_free[u8](?a, buf, total + 1);
    free_str(quoted_msg, a);
    free_str(code_str, a);
}

fun send_result(srv: *lsp_types.Server, id: str, result: str) {
    var a: allocator.Allocator = srv.alloc;

    val prefix: str = "{\"jsonrpc\":\"2.0\",\"id\":";
    val mid:    str = ",\"result\":";
    val suffix: str = "}";

    val id_len: usize = str_len(id);
    val result_len: usize = str_len(result);

    val total: usize = str_len(prefix) + id_len + str_len(mid) + result_len + str_len(suffix);

    val buf_res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, total + 1);
    if (!buf_res.tag) {
        ret;
    }
    val buf: *u8 = buf_res.value.ok;

    var off: usize = 0;
    off = append(buf, off, prefix);
    off = append(buf, off, id);
    off = append(buf, off, mid);
    off = append(buf, off, result);
    off = append(buf, off, suffix);
    buf[off] = 0;

    transport.send_message(buf::str, a);
    allocator.allocator_free[u8](?a, buf, total + 1);
}

fun send_null_result(srv: *lsp_types.Server, id: str) {
    send_result(srv, id, "null");
}

# ============================================================================
# lifecycle handlers
# ============================================================================

pub fun handle_initialize(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);

    if (id == nil) {
        print.eprintln("mach-lsp: initialize: missing id");
        ret;
    }

    srv.status = lsp_types.STATUS_RUNNING;

    val capabilities: str = "{\"capabilities\":{\"textDocumentSync\":1,\"hoverProvider\":true,\"definitionProvider\":true,\"referencesProvider\":true,\"renameProvider\":{\"prepareProvider\":true},\"completionProvider\":{},\"documentSymbolProvider\":true},\"serverInfo\":{\"name\":\"mach-lsp\",\"version\":\"0.3.2\"}}";

    send_result(srv, id, capabilities);
    free_str(id, a);
}

pub fun handle_shutdown(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);

    srv.status = lsp_types.STATUS_SHUTTING_DOWN;

    if (id != nil) {
        send_null_result(srv, id);
        free_str(id, a);
    }
}

pub fun handle_exit(srv: *lsp_types.Server) {
    if (srv.status != lsp_types.STATUS_SHUTTING_DOWN) {
        srv.exit_code = 1;
    }
    srv.status = lsp_types.STATUS_EXITED;
}

# ============================================================================
# document synchronization
# ============================================================================

pub fun handle_did_open(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val anchor: str = "\"textDocument\"";

    val uri: str = json.extract_after(body, anchor, "\"uri\"", a);
    val text: str = json.extract_after(body, anchor, "\"text\"", a);

    if (uri != nil) {
        val doc: *workspace.Document = workspace.open(?srv.ws, uri, text);
        if (doc != nil) {
            diagnostics.publish_diagnostics(doc, a);
        }
    }

    free_str(uri, a);
    free_str(text, a);
}

pub fun handle_did_change(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val anchor: str = "\"textDocument\"";

    val uri: str = json.extract_after(body, anchor, "\"uri\"", a);

    val text_anchor: str = "\"contentChanges\"";
    val text: str = json.extract_after(body, text_anchor, "\"text\"", a);

    if (uri != nil) {
        analysis.invalidate(?srv.ac, uri);
        val doc: *workspace.Document = workspace.find(?srv.ws, uri);
        if (doc != nil) {
            workspace.update(?srv.ws, doc, text);
            diagnostics.publish_diagnostics(doc, a);
        }
    }

    free_str(uri, a);
    free_str(text, a);
}

pub fun handle_did_close(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val anchor: str = "\"textDocument\"";

    val uri: str = json.extract_after(body, anchor, "\"uri\"", a);
    if (uri != nil) {
        analysis.invalidate(?srv.ac, uri);
        val doc: *workspace.Document = workspace.find(?srv.ws, uri);
        if (doc != nil) {
            diagnostics.clear_diagnostics(doc, a);
        }
        workspace.close(?srv.ws, uri);
    }

    free_str(uri, a);
}

# ============================================================================
# language features (stubs — real implementations in subsequent issues)
# ============================================================================

pub fun handle_hover(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);
    if (id == nil) {
        ret;
    }

    # TODO: #3 — resolve symbol at cursor, format type info as markdown
    send_null_result(srv, id);
    free_str(id, a);
}

pub fun handle_definition(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);
    if (id == nil) { ret; }

    val td_anchor: str = "\"textDocument\"";
    val uri: str = json.extract_after(body, td_anchor, "\"uri\"", a);

    val pos_anchor: str = "\"position\"";
    val line: i64 = json.extract_number_after(body, pos_anchor, "\"line\"", a);
    val character: i64 = json.extract_number_after(body, pos_anchor, "\"character\"", a);

    if (uri == nil) {
        send_null_result(srv, id);
        free_str(id, a);
        ret;
    }

    val doc: *workspace.Document = workspace.find(?srv.ws, uri);
    if (doc == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    val ar: *analysis.AnalysisResult = analysis.get_analysis(?srv.ac, doc);
    if (ar == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    val offset: usize = workspace.position_to_offset(doc, line::usize, character::usize);
    val node: *ast.Node = analysis.find_node_at_offset(ar.root, offset::i32);
    if (node == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    val sym: *symbol.Symbol = analysis.get_node_symbol(node);
    if (sym == nil || sym.decl_node == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    val decl_pos: i32 = sym.decl_node.tok.pos;
    val decl_len: i32 = sym.decl_node.tok.len;

    var def_line: usize = 0;
    var def_char: usize = 0;
    workspace.offset_to_position(doc, decl_pos::usize, ?def_line, ?def_char);

    var end_line: usize = 0;
    var end_char: usize = 0;
    if (decl_len > 0) {
        workspace.offset_to_position(doc, (decl_pos + decl_len)::usize, ?end_line, ?end_char);
    }
    or {
        end_line = def_line;
        end_char = def_char + 1;
    }

    val location: str = build_location_json(doc.uri, def_line, def_char, end_line, end_char, a);
    if (location != nil) {
        send_result(srv, id, location);
        free_str(location, a);
    }
    or {
        send_null_result(srv, id);
    }

    free_str(uri, a);
    free_str(id, a);
}

pub fun handle_references(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);
    if (id == nil) { ret; }

    val td_anchor: str = "\"textDocument\"";
    val uri: str = json.extract_after(body, td_anchor, "\"uri\"", a);

    val pos_anchor: str = "\"position\"";
    val line: i64 = json.extract_number_after(body, pos_anchor, "\"line\"", a);
    val character: i64 = json.extract_number_after(body, pos_anchor, "\"character\"", a);

    if (uri == nil) {
        send_result(srv, id, "[]");
        free_str(id, a);
        ret;
    }

    val doc: *workspace.Document = workspace.find(?srv.ws, uri);
    if (doc == nil) {
        send_result(srv, id, "[]");
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    val ar: *analysis.AnalysisResult = analysis.get_analysis(?srv.ac, doc);
    if (ar == nil) {
        send_result(srv, id, "[]");
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    val offset: usize = workspace.position_to_offset(doc, line::usize, character::usize);
    val node: *ast.Node = analysis.find_node_at_offset(ar.root, offset::i32);
    if (node == nil) {
        send_result(srv, id, "[]");
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    val sym: *symbol.Symbol = analysis.get_node_symbol(node);
    if (sym == nil) {
        send_result(srv, id, "[]");
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    # collect up to 1024 references
    val max_refs: i32 = 1024;
    val refs_res: Result[**ast.Node, allocator.AllocError] =
        allocator.allocator_alloc[*ast.Node](?a, max_refs::usize);
    if (!refs_res.tag) {
        send_result(srv, id, "[]");
        free_str(uri, a);
        free_str(id, a);
        ret;
    }
    val refs: **ast.Node = refs_res.value.ok;

    val ref_count: i32 = analysis.collect_references(ar.root, sym, true, refs, max_refs);

    val result_str: str = build_locations_json(doc, refs, ref_count, a);
    if (result_str != nil) {
        send_result(srv, id, result_str);
        free_str(result_str, a);
    }
    or {
        send_result(srv, id, "[]");
    }

    allocator.allocator_free[*ast.Node](?a, refs, max_refs::usize);
    free_str(uri, a);
    free_str(id, a);
}

pub fun handle_prepare_rename(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);
    if (id == nil) { ret; }

    val td_anchor: str = "\"textDocument\"";
    val uri: str = json.extract_after(body, td_anchor, "\"uri\"", a);

    val pos_anchor: str = "\"position\"";
    val line: i64 = json.extract_number_after(body, pos_anchor, "\"line\"", a);
    val character: i64 = json.extract_number_after(body, pos_anchor, "\"character\"", a);

    if (uri == nil) {
        send_null_result(srv, id);
        free_str(id, a);
        ret;
    }

    val doc: *workspace.Document = workspace.find(?srv.ws, uri);
    if (doc == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    val ar: *analysis.AnalysisResult = analysis.get_analysis(?srv.ac, doc);
    if (ar == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    val offset: usize = workspace.position_to_offset(doc, line::usize, character::usize);
    val node: *ast.Node = analysis.find_node_at_offset(ar.root, offset::i32);
    if (node == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    val sym: *symbol.Symbol = analysis.get_node_symbol(node);
    if (sym == nil || sym.decl_node == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    # reject external symbols — they live in other files we can't edit
    if (sym.kind == symbol.SYM_EXT || sym.kind == symbol.SYM_MODULE) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    # use the declaration node's token for the range
    val decl_pos: i32 = sym.decl_node.tok.pos;
    val decl_len: i32 = sym.decl_node.tok.len;

    var sl: usize = 0;
    var sc: usize = 0;
    workspace.offset_to_position(doc, decl_pos::usize, ?sl, ?sc);

    var el: usize = 0;
    var ec: usize = 0;
    if (decl_len > 0) {
        workspace.offset_to_position(doc, (decl_pos + decl_len)::usize, ?el, ?ec);
    }
    or {
        el = sl;
        ec = sc + 1;
    }

    # build { "range": {...}, "placeholder": "name" }
    val result_str: str = build_prepare_rename_json(sym.name, sl, sc, el, ec, a);
    if (result_str != nil) {
        send_result(srv, id, result_str);
        free_str(result_str, a);
    }
    or {
        send_null_result(srv, id);
    }

    free_str(uri, a);
    free_str(id, a);
}

pub fun handle_rename(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);
    if (id == nil) { ret; }

    val td_anchor: str = "\"textDocument\"";
    val uri: str = json.extract_after(body, td_anchor, "\"uri\"", a);

    val pos_anchor: str = "\"position\"";
    val line: i64 = json.extract_number_after(body, pos_anchor, "\"line\"", a);
    val character: i64 = json.extract_number_after(body, pos_anchor, "\"character\"", a);

    val new_name: str = json.extract_string(body, "\"newName\"", a);

    if (uri == nil || new_name == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }

    # validate new name is not empty
    val new_name_len: usize = str_len(new_name);
    if (new_name_len == 0) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }

    # reject if new name is a keyword
    val tag: u8 = token.keyword_from_str(new_name);
    if (tag != token.TAG_IDENT) {
        send_error(srv, id, -32602, "new name is a keyword");
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }

    val doc: *workspace.Document = workspace.find(?srv.ws, uri);
    if (doc == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }

    val ar: *analysis.AnalysisResult = analysis.get_analysis(?srv.ac, doc);
    if (ar == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }

    val offset: usize = workspace.position_to_offset(doc, line::usize, character::usize);
    val node: *ast.Node = analysis.find_node_at_offset(ar.root, offset::i32);
    if (node == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }

    val sym: *symbol.Symbol = analysis.get_node_symbol(node);
    if (sym == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }

    # reject external/module symbols
    if (sym.kind == symbol.SYM_EXT || sym.kind == symbol.SYM_MODULE) {
        send_error(srv, id, -32602, "cannot rename external or module symbol");
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }

    # collect references (including declaration)
    val max_refs: i32 = 1024;
    val refs_res: Result[**ast.Node, allocator.AllocError] =
        allocator.allocator_alloc[*ast.Node](?a, max_refs::usize);
    if (!refs_res.tag) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }
    val refs: **ast.Node = refs_res.value.ok;

    val ref_count: i32 = analysis.collect_references(ar.root, sym, true, refs, max_refs);
    if (ref_count == 0) {
        send_null_result(srv, id);
        allocator.allocator_free[*ast.Node](?a, refs, max_refs::usize);
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }

    # build WorkspaceEdit: { "changes": { "<uri>": [ TextEdit, ... ] } }
    val result_str: str = build_workspace_edit_json(doc, refs, ref_count, new_name, a);
    if (result_str != nil) {
        send_result(srv, id, result_str);
        free_str(result_str, a);
    }
    or {
        send_null_result(srv, id);
    }

    allocator.allocator_free[*ast.Node](?a, refs, max_refs::usize);
    free_str(uri, a);
    free_str(new_name, a);
    free_str(id, a);
}

pub fun handle_completion(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);
    if (id != nil) {
        # TODO: #8 — scope-aware symbol completion
        send_result(srv, id, "[]");
        free_str(id, a);
    }
}

pub fun handle_document_symbol(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);
    if (id != nil) {
        # TODO: #5 — walk AST for document symbols
        send_result(srv, id, "[]");
        free_str(id, a);
    }
}

# ============================================================================
# internal utilities
# ============================================================================

fun append(buf: *u8, offset: usize, s: str) usize {
    if (s != nil) {
        val slen: usize = str_len(s);
        if (slen > 0) {
            mem.raw_copy((buf + offset)::ptr, s::ptr, slen);
        }
        ret offset + slen;
    }
    ret offset;
}

fun build_location_json(
    uri: str, start_line: usize, start_char: usize,
    end_line: usize, end_char: usize,
    alloc: allocator.Allocator
) str {
    var a: allocator.Allocator = alloc;

    val quoted_uri: str = json.quote(uri, a);
    val sl: str = json.format_usize(start_line, a);
    val sc: str = json.format_usize(start_char, a);
    val el: str = json.format_usize(end_line, a);
    val ec: str = json.format_usize(end_char, a);

    val p1: str = "{\"uri\":";
    val p2: str = ",\"range\":{\"start\":{\"line\":";
    val p3: str = ",\"character\":";
    val p4: str = "},\"end\":{\"line\":";
    val p5: str = ",\"character\":";
    val p6: str = "}}}";

    var qu_len: usize = 0;
    if (quoted_uri != nil) { qu_len = str_len(quoted_uri); }
    var sl_len: usize = 0;
    if (sl != nil) { sl_len = str_len(sl); }
    var sc_len: usize = 0;
    if (sc != nil) { sc_len = str_len(sc); }
    var el_len: usize = 0;
    if (el != nil) { el_len = str_len(el); }
    var ec_len: usize = 0;
    if (ec != nil) { ec_len = str_len(ec); }

    val total: usize = str_len(p1) + qu_len + str_len(p2) + sl_len + str_len(p3) + sc_len +
                       str_len(p4) + el_len + str_len(p5) + ec_len + str_len(p6);

    val buf_res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, total + 1);
    if (!buf_res.tag) {
        free_str(quoted_uri, a);
        free_str(sl, a);
        free_str(sc, a);
        free_str(el, a);
        free_str(ec, a);
        ret nil;
    }
    val buf: *u8 = buf_res.value.ok;

    var off: usize = 0;
    off = append(buf, off, p1);
    off = append(buf, off, quoted_uri);
    off = append(buf, off, p2);
    off = append(buf, off, sl);
    off = append(buf, off, p3);
    off = append(buf, off, sc);
    off = append(buf, off, p4);
    off = append(buf, off, el);
    off = append(buf, off, p5);
    off = append(buf, off, ec);
    off = append(buf, off, p6);
    buf[off] = 0;

    free_str(quoted_uri, a);
    free_str(sl, a);
    free_str(sc, a);
    free_str(el, a);
    free_str(ec, a);

    ret buf::str;
}

fun build_locations_json(
    doc: *workspace.Document, refs: **ast.Node, count: i32,
    alloc: allocator.Allocator
) str {
    if (count == 0) { ret nil; }

    var a: allocator.Allocator = alloc;

    # build each location string and compute total length
    val locs_res: Result[*str, allocator.AllocError] =
        allocator.allocator_alloc[str](?a, count::usize);
    if (!locs_res.tag) { ret nil; }
    val locs: *str = locs_res.value.ok;

    var total: usize = 2;  # "[]"
    var i: i32 = 0;
    for (i < count) {
        val ref_node: *ast.Node = refs[i];
        val ref_pos: i32 = ref_node.tok.pos;
        val ref_len: i32 = ref_node.tok.len;

        var sl: usize = 0;
        var sc: usize = 0;
        workspace.offset_to_position(doc, ref_pos::usize, ?sl, ?sc);

        var el: usize = 0;
        var ec: usize = 0;
        if (ref_len > 0) {
            workspace.offset_to_position(doc, (ref_pos + ref_len)::usize, ?el, ?ec);
        }
        or {
            el = sl;
            ec = sc + 1;
        }

        val loc: str = build_location_json(doc.uri, sl, sc, el, ec, a);
        locs[i] = loc;
        if (loc != nil) { total = total + str_len(loc); }
        if (i > 0) { total = total + 1; }  # comma
        i = i + 1;
    }

    val buf_res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, total + 1);
    if (!buf_res.tag) {
        i = 0;
        for (i < count) { free_str(locs[i], a); i = i + 1; }
        allocator.allocator_free[str](?a, locs, count::usize);
        ret nil;
    }
    val buf: *u8 = buf_res.value.ok;

    var off: usize = 0;
    buf[off] = '[';
    off = off + 1;

    i = 0;
    for (i < count) {
        if (i > 0) {
            buf[off] = ',';
            off = off + 1;
        }
        off = append(buf, off, locs[i]);
        i = i + 1;
    }

    buf[off] = ']';
    off = off + 1;
    buf[off] = 0;

    i = 0;
    for (i < count) { free_str(locs[i], a); i = i + 1; }
    allocator.allocator_free[str](?a, locs, count::usize);

    ret buf::str;
}

fun build_prepare_rename_json(
    name: str, start_line: usize, start_char: usize,
    end_line: usize, end_char: usize,
    alloc: allocator.Allocator
) str {
    var a: allocator.Allocator = alloc;

    val quoted_name: str = json.quote(name, a);
    val sl: str = json.format_usize(start_line, a);
    val sc: str = json.format_usize(start_char, a);
    val el: str = json.format_usize(end_line, a);
    val ec: str = json.format_usize(end_char, a);

    val p1: str = "{\"range\":{\"start\":{\"line\":";
    val p2: str = ",\"character\":";
    val p3: str = "},\"end\":{\"line\":";
    val p4: str = ",\"character\":";
    val p5: str = "}},\"placeholder\":";
    val p6: str = "}";

    var qn_len: usize = 0;
    if (quoted_name != nil) { qn_len = str_len(quoted_name); }
    var sl_len: usize = 0;
    if (sl != nil) { sl_len = str_len(sl); }
    var sc_len: usize = 0;
    if (sc != nil) { sc_len = str_len(sc); }
    var el_len: usize = 0;
    if (el != nil) { el_len = str_len(el); }
    var ec_len: usize = 0;
    if (ec != nil) { ec_len = str_len(ec); }

    val total: usize = str_len(p1) + sl_len + str_len(p2) + sc_len +
                       str_len(p3) + el_len + str_len(p4) + ec_len +
                       str_len(p5) + qn_len + str_len(p6);

    val buf_res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, total + 1);
    if (!buf_res.tag) {
        free_str(quoted_name, a);
        free_str(sl, a);
        free_str(sc, a);
        free_str(el, a);
        free_str(ec, a);
        ret nil;
    }
    val buf: *u8 = buf_res.value.ok;

    var off: usize = 0;
    off = append(buf, off, p1);
    off = append(buf, off, sl);
    off = append(buf, off, p2);
    off = append(buf, off, sc);
    off = append(buf, off, p3);
    off = append(buf, off, el);
    off = append(buf, off, p4);
    off = append(buf, off, ec);
    off = append(buf, off, p5);
    off = append(buf, off, quoted_name);
    off = append(buf, off, p6);
    buf[off] = 0;

    free_str(quoted_name, a);
    free_str(sl, a);
    free_str(sc, a);
    free_str(el, a);
    free_str(ec, a);

    ret buf::str;
}

fun build_workspace_edit_json(
    doc: *workspace.Document, refs: **ast.Node, count: i32,
    new_name: str, alloc: allocator.Allocator
) str {
    if (count == 0) { ret nil; }

    var a: allocator.Allocator = alloc;

    # build text edits array
    val edits_res: Result[*str, allocator.AllocError] =
        allocator.allocator_alloc[str](?a, count::usize);
    if (!edits_res.tag) { ret nil; }
    val edits: *str = edits_res.value.ok;

    val quoted_new_name: str = json.quote(new_name, a);

    var edits_total: usize = 0;
    var i: i32 = 0;
    for (i < count) {
        val ref_node: *ast.Node = refs[i];
        val ref_pos: i32 = ref_node.tok.pos;
        val ref_len: i32 = ref_node.tok.len;

        var sl: usize = 0;
        var sc: usize = 0;
        workspace.offset_to_position(doc, ref_pos::usize, ?sl, ?sc);

        var el: usize = 0;
        var ec: usize = 0;
        if (ref_len > 0) {
            workspace.offset_to_position(doc, (ref_pos + ref_len)::usize, ?el, ?ec);
        }
        or {
            el = sl;
            ec = sc + 1;
        }

        val edit: str = build_text_edit_json(sl, sc, el, ec, quoted_new_name, a);
        edits[i] = edit;
        if (edit != nil) { edits_total = edits_total + str_len(edit); }
        if (i > 0) { edits_total = edits_total + 1; }  # comma
        i = i + 1;
    }

    # build: {"changes":{"<uri>":[edit1,edit2,...]}}
    val quoted_uri: str = json.quote(doc.uri, a);

    val h1: str = "{\"changes\":{";
    val h2: str = ":[";
    val h3: str = "]}}";

    var qu_len: usize = 0;
    if (quoted_uri != nil) { qu_len = str_len(quoted_uri); }

    val total: usize = str_len(h1) + qu_len + str_len(h2) + edits_total + str_len(h3);

    val buf_res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, total + 1);
    if (!buf_res.tag) {
        i = 0;
        for (i < count) { free_str(edits[i], a); i = i + 1; }
        allocator.allocator_free[str](?a, edits, count::usize);
        free_str(quoted_uri, a);
        free_str(quoted_new_name, a);
        ret nil;
    }
    val buf: *u8 = buf_res.value.ok;

    var off: usize = 0;
    off = append(buf, off, h1);
    off = append(buf, off, quoted_uri);
    off = append(buf, off, h2);

    i = 0;
    for (i < count) {
        if (i > 0) {
            buf[off] = ',';
            off = off + 1;
        }
        off = append(buf, off, edits[i]);
        i = i + 1;
    }

    off = append(buf, off, h3);
    buf[off] = 0;

    i = 0;
    for (i < count) { free_str(edits[i], a); i = i + 1; }
    allocator.allocator_free[str](?a, edits, count::usize);
    free_str(quoted_uri, a);
    free_str(quoted_new_name, a);

    ret buf::str;
}

fun build_text_edit_json(
    start_line: usize, start_char: usize,
    end_line: usize, end_char: usize,
    quoted_new_text: str, alloc: allocator.Allocator
) str {
    var a: allocator.Allocator = alloc;

    val sl: str = json.format_usize(start_line, a);
    val sc: str = json.format_usize(start_char, a);
    val el: str = json.format_usize(end_line, a);
    val ec: str = json.format_usize(end_char, a);

    val p1: str = "{\"range\":{\"start\":{\"line\":";
    val p2: str = ",\"character\":";
    val p3: str = "},\"end\":{\"line\":";
    val p4: str = ",\"character\":";
    val p5: str = "}},\"newText\":";
    val p6: str = "}";

    var sl_len: usize = 0;
    if (sl != nil) { sl_len = str_len(sl); }
    var sc_len: usize = 0;
    if (sc != nil) { sc_len = str_len(sc); }
    var el_len: usize = 0;
    if (el != nil) { el_len = str_len(el); }
    var ec_len: usize = 0;
    if (ec != nil) { ec_len = str_len(ec); }
    var qnt_len: usize = 0;
    if (quoted_new_text != nil) { qnt_len = str_len(quoted_new_text); }

    val total: usize = str_len(p1) + sl_len + str_len(p2) + sc_len +
                       str_len(p3) + el_len + str_len(p4) + ec_len +
                       str_len(p5) + qnt_len + str_len(p6);

    val buf_res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, total + 1);
    if (!buf_res.tag) {
        free_str(sl, a);
        free_str(sc, a);
        free_str(el, a);
        free_str(ec, a);
        ret nil;
    }
    val buf: *u8 = buf_res.value.ok;

    var off: usize = 0;
    off = append(buf, off, p1);
    off = append(buf, off, sl);
    off = append(buf, off, p2);
    off = append(buf, off, sc);
    off = append(buf, off, p3);
    off = append(buf, off, el);
    off = append(buf, off, p4);
    off = append(buf, off, ec);
    off = append(buf, off, p5);
    off = append(buf, off, quoted_new_text);
    off = append(buf, off, p6);
    buf[off] = 0;

    free_str(sl, a);
    free_str(sc, a);
    free_str(el, a);
    free_str(ec, a);

    ret buf::str;
}

fun free_str(s: str, alloc: allocator.Allocator) {
    if (s != nil) {
        val len: usize = str_len(s);
        var a: allocator.Allocator = alloc;
        allocator.allocator_free_bytes(?a, s::ptr, len + 1, 1);
    }
}
