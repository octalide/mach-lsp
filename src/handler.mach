use std.types.bool;
use std.types.size;
use std.types.string;
use std.types.result;

use allocator: std.allocator;
use mem:       std.memory;
use print:     std.print;

use transport: mls.transport;
use workspace: mls.workspace;
use json:      mls.json;

use ast:      mach.compiler.ast;
use pipeline: mach.compiler.pipeline;
use sema:     mach.compiler.sema;
use symbol:   mach.compiler.symbol;
use token:    mach.compiler.token;
use type:     mach.compiler.type;

use lsp_types:   mls.lsp_types;
use diagnostics: mls.diagnostics;
use analysis:    mls.analysis;

# mls.handler: LSP request/notification handler implementations.

# ============================================================================
# response construction helpers
# ============================================================================

pub fun send_error(srv: *lsp_types.Server, id: str, code: i64, message: str) {
    var a: allocator.Allocator = srv.alloc;

    val quoted_msg: str = json.quote(message, a);
    val code_str: str = json.format_i64(code, a);

    val prefix:  str = "{\"jsonrpc\":\"2.0\",\"id\":";
    val mid1:    str = ",\"error\":{\"code\":";
    val mid2:    str = ",\"message\":";
    val suffix:  str = "}}";

    val id_len: usize = str_len(id);
    val quoted_msg_len: usize = str_len(quoted_msg);
    val code_str_len: usize = str_len(code_str);

    val total: usize = str_len(prefix) + id_len + str_len(mid1) + code_str_len +
                       str_len(mid2) + quoted_msg_len + str_len(suffix);

    val buf_res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, total + 1);
    if (!buf_res.tag) {
        free_str(quoted_msg, a);
        free_str(code_str, a);
        ret;
    }
    val buf: *u8 = buf_res.value.ok;

    var off: usize = 0;
    off = append(buf, off, prefix);
    off = append(buf, off, id);
    off = append(buf, off, mid1);
    off = append(buf, off, code_str);
    off = append(buf, off, mid2);
    off = append(buf, off, quoted_msg);
    off = append(buf, off, suffix);
    buf[off] = 0;

    transport.send_message(buf::str, a);

    allocator.allocator_free[u8](?a, buf, total + 1);
    free_str(quoted_msg, a);
    free_str(code_str, a);
}

fun send_result(srv: *lsp_types.Server, id: str, result: str) {
    var a: allocator.Allocator = srv.alloc;

    val prefix: str = "{\"jsonrpc\":\"2.0\",\"id\":";
    val mid:    str = ",\"result\":";
    val suffix: str = "}";

    val id_len: usize = str_len(id);
    val result_len: usize = str_len(result);

    val total: usize = str_len(prefix) + id_len + str_len(mid) + result_len + str_len(suffix);

    val buf_res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, total + 1);
    if (!buf_res.tag) {
        ret;
    }
    val buf: *u8 = buf_res.value.ok;

    var off: usize = 0;
    off = append(buf, off, prefix);
    off = append(buf, off, id);
    off = append(buf, off, mid);
    off = append(buf, off, result);
    off = append(buf, off, suffix);
    buf[off] = 0;

    transport.send_message(buf::str, a);
    allocator.allocator_free[u8](?a, buf, total + 1);
}

fun send_null_result(srv: *lsp_types.Server, id: str) {
    send_result(srv, id, "null");
}

# ============================================================================
# lifecycle handlers
# ============================================================================

pub fun handle_initialize(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);

    if (id == nil) {
        print.eprintln("mach-lsp: initialize: missing id");
        ret;
    }

    # extract rootUri from params for workspace config
    val root_uri: str = json.extract_string(body, "\"rootUri\"", a);
    if (root_uri != nil) {
        workspace.set_root(?srv.ws, root_uri);
        free_str(root_uri, a);
    }

    srv.status = lsp_types.STATUS_RUNNING;

    val capabilities: str = "{\"capabilities\":{\"textDocumentSync\":1,\"hoverProvider\":true,\"definitionProvider\":true,\"referencesProvider\":true,\"renameProvider\":{\"prepareProvider\":true},\"completionProvider\":{},\"documentSymbolProvider\":true},\"serverInfo\":{\"name\":\"mach-lsp\",\"version\":\"0.3.2\"}}";

    send_result(srv, id, capabilities);
    free_str(id, a);
}

pub fun handle_shutdown(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);

    srv.status = lsp_types.STATUS_SHUTTING_DOWN;

    if (id != nil) {
        send_null_result(srv, id);
        free_str(id, a);
    }
}

pub fun handle_exit(srv: *lsp_types.Server) {
    if (srv.status != lsp_types.STATUS_SHUTTING_DOWN) {
        srv.exit_code = 1;
    }
    srv.status = lsp_types.STATUS_EXITED;
}

# ============================================================================
# document synchronization
# ============================================================================

pub fun handle_did_open(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val anchor: str = "\"textDocument\"";

    val uri: str = json.extract_after(body, anchor, "\"uri\"", a);
    val text: str = json.extract_after(body, anchor, "\"text\"", a);

    if (uri != nil) {
        val doc: *workspace.Document = workspace.open(?srv.ws, uri, text);
        if (doc != nil) {
            diagnostics.publish_diagnostics(doc, a);
        }
    }

    free_str(uri, a);
    free_str(text, a);
}

pub fun handle_did_change(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val anchor: str = "\"textDocument\"";

    val uri: str = json.extract_after(body, anchor, "\"uri\"", a);

    val text_anchor: str = "\"contentChanges\"";
    val text: str = json.extract_after(body, text_anchor, "\"text\"", a);

    if (uri != nil) {
        analysis.invalidate(?srv.ac, uri);
        val doc: *workspace.Document = workspace.find(?srv.ws, uri);
        if (doc != nil) {
            workspace.update(?srv.ws, doc, text);
            diagnostics.publish_diagnostics(doc, a);
        }
    }

    free_str(uri, a);
    free_str(text, a);
}

pub fun handle_did_close(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val anchor: str = "\"textDocument\"";

    val uri: str = json.extract_after(body, anchor, "\"uri\"", a);
    if (uri != nil) {
        analysis.invalidate(?srv.ac, uri);
        val doc: *workspace.Document = workspace.find(?srv.ws, uri);
        if (doc != nil) {
            diagnostics.clear_diagnostics(doc, a);
        }
        workspace.close(?srv.ws, uri);
    }

    free_str(uri, a);
}

# ============================================================================
# language features (stubs — real implementations in subsequent issues)
# ============================================================================

pub fun handle_hover(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);
    if (id == nil) {
        ret;
    }

    # TODO: #3 — resolve symbol at cursor, format type info as markdown
    send_null_result(srv, id);
    free_str(id, a);
}

pub fun handle_definition(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);
    if (id == nil) { ret; }

    val td_anchor: str = "\"textDocument\"";
    val uri: str = json.extract_after(body, td_anchor, "\"uri\"", a);

    val pos_anchor: str = "\"position\"";
    val line: i64 = json.extract_number_after(body, pos_anchor, "\"line\"", a);
    val character: i64 = json.extract_number_after(body, pos_anchor, "\"character\"", a);

    if (uri == nil) {
        send_null_result(srv, id);
        free_str(id, a);
        ret;
    }

    val doc: *workspace.Document = workspace.find(?srv.ws, uri);
    if (doc == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    val ar: *analysis.AnalysisResult = analysis.get_analysis(?srv.ac, doc, ?srv.ws);
    if (ar == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    val offset: usize = workspace.position_to_offset(doc, line::usize, character::usize);

    val node: *ast.Node = analysis.find_node_at_offset(ar.root, offset::i32);
    if (node == nil) {
        # fallback: check if cursor is in a use declaration
        val use_node: *ast.Node = analysis.find_use_at_offset(ar.root, offset::i32);
        if (use_node != nil) {
            val use_path: str = analysis.get_use_path(use_node);
            if (use_path != nil) {
                val target_mod: *sema.SemaModule = analysis.find_module_by_path(ar, use_path);
                if (target_mod != nil && target_mod.file_path != nil) {
                    val mod_uri: str = workspace.path_to_uri(target_mod.file_path, a);
                    if (mod_uri != nil) {
                        val location: str = build_location_json(mod_uri, 0, 0, 0, 0, a);
                        if (location != nil) {
                            val arr: str = wrap_in_array(location, a);
                            if (arr != nil) {
                                send_result(srv, id, arr);
                                free_str(arr, a);
                            }
                            or {
                                send_result(srv, id, location);
                            }
                            free_str(location, a);
                        }
                        or {
                            send_null_result(srv, id);
                        }
                        free_str(mod_uri, a);
                        free_str(uri, a);
                        free_str(id, a);
                        ret;
                    }
                }
            }
        }

        send_null_result(srv, id);
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    val sym: *symbol.Symbol = analysis.get_node_symbol(node);

    # primary path: symbol resolved directly on the node
    if (sym != nil && sym.decl_node != nil) {
        send_definition_for_symbol(srv, id, uri, doc, ar, sym, a);
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    # fallback 1: module alias identifier — navigate to the module's source file
    if (node.kind == ast.NODE_EXPR_IDENT) {
        val ident_name: str = analysis.get_ident_name(node);
        if (ident_name != nil) {
            val alias_mod: *sema.SemaModule = analysis.find_module_alias(ar, ident_name);
            if (alias_mod != nil && alias_mod.file_path != nil) {
                val mod_uri: str = workspace.path_to_uri(alias_mod.file_path, a);
                if (mod_uri != nil) {
                    # navigate to line 0, col 0 of the module file
                    val location: str = build_location_json(mod_uri, 0, 0, 0, 0, a);
                    if (location != nil) {
                        val arr: str = wrap_in_array(location, a);
                        if (arr != nil) {
                            send_result(srv, id, arr);
                            free_str(arr, a);
                        }
                        or {
                            send_result(srv, id, location);
                        }
                        free_str(location, a);
                    }
                    or {
                        send_null_result(srv, id);
                    }
                    free_str(mod_uri, a);
                    free_str(uri, a);
                    free_str(id, a);
                    ret;
                }
            }
        }
    }

    # fallback 2: dotted TYPE_NAME (e.g. lsp_types.Server) — resolve the
    # module alias and optionally the named declaration within that module.
    if (node.kind == ast.NODE_TYPE_NAME) {
        val type_path: str = analysis.get_type_name_path(node);
        if (type_path != nil) {
            # find the dot separating module alias from type name
            val path_len: usize = str_len(type_path);
            var dot_pos: usize = 0;
            var found_dot: bool = false;
            for (dot_pos < path_len) {
                if (type_path[dot_pos] == 46) { # 46 = '.'
                    found_dot = true;
                    brk;
                }
                dot_pos = dot_pos + 1;
            }

            if (found_dot && dot_pos > 0 && dot_pos + 1 < path_len) {
                # extract module alias (before dot) via substring match
                # build alias name from the path up to the dot
                val alias_res: Result[*u8, allocator.AllocError] =
                    allocator.allocator_alloc[u8](?a, dot_pos + 1);
                if (alias_res.tag) {
                    val alias_buf: *u8 = alias_res.value.ok;
                    mem.raw_copy(alias_buf::ptr, type_path::ptr, dot_pos);
                    alias_buf[dot_pos] = 0;
                    val alias_name: str = alias_buf::str;

                    val target_mod: *sema.SemaModule = analysis.find_module_alias(ar, alias_name);
                    allocator.allocator_free[u8](?a, alias_buf, dot_pos + 1);

                    if (target_mod != nil && target_mod.file_path != nil) {
                        # cursor is after the dot — try to find the specific declaration
                        val tok_start: i32 = node.tok.pos;
                        val dot_byte: i32 = tok_start + dot_pos::i32;

                        if (offset::i32 > dot_byte) {
                            # cursor is on the type name part — find the declaration
                            val type_name_res: Result[*u8, allocator.AllocError] =
                                allocator.allocator_alloc[u8](?a, path_len - dot_pos);
                            if (type_name_res.tag) {
                                val tn_buf: *u8 = type_name_res.value.ok;
                                val tn_len: usize = path_len - dot_pos - 1;
                                val tn_off: usize = dot_pos + 1;
                                mem.raw_copy(tn_buf::ptr, (type_path::ptr + tn_off)::ptr, tn_len);
                                tn_buf[tn_len] = 0;
                                val decl_name: str = tn_buf::str;

                                val decl_node: *ast.Node = analysis.find_decl_in_module(target_mod, decl_name);
                                allocator.allocator_free[u8](?a, tn_buf, path_len - dot_pos);

                                if (decl_node != nil && target_mod.source != nil) {
                                    val mod_uri: str = workspace.path_to_uri(target_mod.file_path, a);
                                    if (mod_uri != nil) {
                                        val dp: i32 = decl_node.tok.pos;
                                        val dl: i32 = pipeline.pos_to_line(target_mod.source, dp);
                                        val dc: i32 = pipeline.pos_to_col(target_mod.source, dp);
                                        var tl: usize = 0;
                                        var tc: usize = 0;
                                        if (dl > 0) { tl = (dl - 1)::usize; }
                                        if (dc > 0) { tc = (dc - 1)::usize; }
                                        val location: str = build_location_json(mod_uri, tl, tc, tl, tc + 1, a);
                                        if (location != nil) {
                                            val arr: str = wrap_in_array(location, a);
                                            if (arr != nil) {
                                                send_result(srv, id, arr);
                                                free_str(arr, a);
                                            }
                                            or {
                                                send_result(srv, id, location);
                                            }
                                            free_str(location, a);
                                        }
                                        or {
                                            send_null_result(srv, id);
                                        }
                                        free_str(mod_uri, a);
                                        free_str(uri, a);
                                        free_str(id, a);
                                        ret;
                                    }
                                }
                            }
                        }

                        # cursor is on the module alias part, or couldn't find the decl
                        # navigate to the module file
                        val mod_uri: str = workspace.path_to_uri(target_mod.file_path, a);
                        if (mod_uri != nil) {
                            val location: str = build_location_json(mod_uri, 0, 0, 0, 0, a);
                            if (location != nil) {
                                val arr: str = wrap_in_array(location, a);
                                if (arr != nil) {
                                    send_result(srv, id, arr);
                                    free_str(arr, a);
                                }
                                or {
                                    send_result(srv, id, location);
                                }
                                free_str(location, a);
                            }
                            or {
                                send_null_result(srv, id);
                            }
                            free_str(mod_uri, a);
                            free_str(uri, a);
                            free_str(id, a);
                            ret;
                        }
                    }
                }
            }
        }
    }

    # fallback 3: struct field access — resolve field declaration via type info
    if (node.kind == ast.NODE_EXPR_FIELD) {
        val field_name: str = analysis.get_field_name(node);
        val record_type: *type.Type = analysis.get_object_record_type(node);

        if (field_name != nil && record_type != nil && record_type.name != nil) {
            val rec_mod: *sema.SemaModule = analysis.find_record_module(ar, record_type.name);
            if (rec_mod != nil) {
                val rec_decl: *ast.Node = analysis.find_decl_in_module(rec_mod, record_type.name);
                if (rec_decl != nil) {
                    val field_decl: *ast.Node = analysis.find_field_in_record_decl(rec_decl, field_name);
                    if (field_decl != nil) {
                        val mod_uri: str = workspace.path_to_uri(rec_mod.file_path, a);
                        if (mod_uri != nil) {
                            val fp: i32 = field_decl.tok.pos;

                            var fl: usize = 0;
                            var fc: usize = 0;

                            if (rec_mod.source != nil) {
                                val rl: i32 = pipeline.pos_to_line(rec_mod.source, fp);
                                val rc: i32 = pipeline.pos_to_col(rec_mod.source, fp);
                                if (rl > 0) { fl = (rl - 1)::usize; }
                                if (rc > 0) { fc = (rc - 1)::usize; }
                            }

                            val location: str = build_location_json(mod_uri, fl, fc, fl, fc + 1, a);
                            if (location != nil) {
                                val arr: str = wrap_in_array(location, a);
                                if (arr != nil) {
                                    send_result(srv, id, arr);
                                    free_str(arr, a);
                                }
                                or {
                                    send_result(srv, id, location);
                                }
                                free_str(location, a);
                            }
                            or {
                                send_null_result(srv, id);
                            }
                            free_str(mod_uri, a);
                            free_str(uri, a);
                            free_str(id, a);
                            ret;
                        }
                    }
                }
            }
        }
    }

    send_null_result(srv, id);
    free_str(uri, a);
    free_str(id, a);
}

fun send_definition_for_symbol(
    srv: *lsp_types.Server, id: str, uri: str,
    doc: *workspace.Document, ar: *analysis.AnalysisResult,
    sym: *symbol.Symbol, alloc: allocator.Allocator
) {
    var a: allocator.Allocator = alloc;

    val decl_pos: i32 = sym.decl_node.tok.pos;
    val decl_len: i32 = sym.decl_node.tok.len;

    # check if symbol is from a different module (cross-file)
    var target_uri: str = nil;
    var target_source: str = nil;
    var is_cross_file: bool = false;

    if (sym.module_path != nil && ar.sem.module_path != nil) {
        if (!str_equals(sym.module_path, ar.sem.module_path)) {
            val target_mod: *sema.SemaModule = analysis.find_module_by_path(ar, sym.module_path);
            if (target_mod != nil && target_mod.file_path != nil && target_mod.source != nil) {
                target_uri = workspace.path_to_uri(target_mod.file_path, a);
                target_source = target_mod.source;
                is_cross_file = true;
            }
        }
    }

    var def_line: usize = 0;
    var def_char: usize = 0;
    var end_line: usize = 0;
    var end_char: usize = 0;

    if (is_cross_file) {
        val l: i32 = pipeline.pos_to_line(target_source, decl_pos);
        val c: i32 = pipeline.pos_to_col(target_source, decl_pos);
        if (l > 0) { def_line = (l - 1)::usize; }
        if (c > 0) { def_char = (c - 1)::usize; }
        if (decl_len > 0) {
            val el: i32 = pipeline.pos_to_line(target_source, decl_pos + decl_len);
            val ec: i32 = pipeline.pos_to_col(target_source, decl_pos + decl_len);
            if (el > 0) { end_line = (el - 1)::usize; }
            if (ec > 0) { end_char = (ec - 1)::usize; }
        }
        or {
            end_line = def_line;
            end_char = def_char + 1;
        }
    }
    or {
        workspace.offset_to_position(doc, decl_pos::usize, ?def_line, ?def_char);
        if (decl_len > 0) {
            workspace.offset_to_position(doc, (decl_pos + decl_len)::usize, ?end_line, ?end_char);
        }
        or {
            end_line = def_line;
            end_char = def_char + 1;
        }
    }

    var loc_uri: str = doc.uri;
    if (is_cross_file && target_uri != nil) { loc_uri = target_uri; }

    val location: str = build_location_json(loc_uri, def_line, def_char, end_line, end_char, a);
    if (location != nil) {
        val arr: str = wrap_in_array(location, a);
        if (arr != nil) {
            send_result(srv, id, arr);
            free_str(arr, a);
        }
        or {
            send_result(srv, id, location);
        }
        free_str(location, a);
    }
    or {
        send_null_result(srv, id);
    }

    if (target_uri != nil) { free_str(target_uri, a); }
}

pub fun handle_references(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);
    if (id == nil) { ret; }

    val td_anchor: str = "\"textDocument\"";
    val uri: str = json.extract_after(body, td_anchor, "\"uri\"", a);

    val pos_anchor: str = "\"position\"";
    val line: i64 = json.extract_number_after(body, pos_anchor, "\"line\"", a);
    val character: i64 = json.extract_number_after(body, pos_anchor, "\"character\"", a);

    if (uri == nil) {
        send_result(srv, id, "[]");
        free_str(id, a);
        ret;
    }

    val doc: *workspace.Document = workspace.find(?srv.ws, uri);
    if (doc == nil) {
        send_result(srv, id, "[]");
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    val ar: *analysis.AnalysisResult = analysis.get_analysis(?srv.ac, doc, ?srv.ws);
    if (ar == nil) {
        send_result(srv, id, "[]");
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    val offset: usize = workspace.position_to_offset(doc, line::usize, character::usize);
    val node: *ast.Node = analysis.find_node_at_offset(ar.root, offset::i32);
    if (node == nil) {
        send_result(srv, id, "[]");
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    val sym: *symbol.Symbol = analysis.get_node_symbol(node);
    if (sym == nil) {
        send_result(srv, id, "[]");
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    # collect up to 1024 references
    val max_refs: i32 = 1024;
    val refs_res: Result[**ast.Node, allocator.AllocError] =
        allocator.allocator_alloc[*ast.Node](?a, max_refs::usize);
    if (!refs_res.tag) {
        send_result(srv, id, "[]");
        free_str(uri, a);
        free_str(id, a);
        ret;
    }
    val refs: **ast.Node = refs_res.value.ok;

    val ref_count: i32 = analysis.collect_references(ar.root, sym, true, refs, max_refs);

    val result_str: str = build_locations_json(doc, refs, ref_count, a);
    if (result_str != nil) {
        send_result(srv, id, result_str);
        free_str(result_str, a);
    }
    or {
        send_result(srv, id, "[]");
    }

    allocator.allocator_free[*ast.Node](?a, refs, max_refs::usize);
    free_str(uri, a);
    free_str(id, a);
}

pub fun handle_prepare_rename(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);
    if (id == nil) { ret; }

    val td_anchor: str = "\"textDocument\"";
    val uri: str = json.extract_after(body, td_anchor, "\"uri\"", a);

    val pos_anchor: str = "\"position\"";
    val line: i64 = json.extract_number_after(body, pos_anchor, "\"line\"", a);
    val character: i64 = json.extract_number_after(body, pos_anchor, "\"character\"", a);

    if (uri == nil) {
        send_null_result(srv, id);
        free_str(id, a);
        ret;
    }

    val doc: *workspace.Document = workspace.find(?srv.ws, uri);
    if (doc == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    val ar: *analysis.AnalysisResult = analysis.get_analysis(?srv.ac, doc, ?srv.ws);
    if (ar == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    val offset: usize = workspace.position_to_offset(doc, line::usize, character::usize);
    val node: *ast.Node = analysis.find_node_at_offset(ar.root, offset::i32);
    if (node == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    val sym: *symbol.Symbol = analysis.get_node_symbol(node);
    if (sym == nil || sym.decl_node == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    # reject external symbols — they live in other files we can't edit
    if (sym.kind == symbol.SYM_EXT || sym.kind == symbol.SYM_MODULE) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(id, a);
        ret;
    }

    # use the declaration node's token for the range
    val decl_pos: i32 = sym.decl_node.tok.pos;
    val decl_len: i32 = sym.decl_node.tok.len;

    var sl: usize = 0;
    var sc: usize = 0;
    workspace.offset_to_position(doc, decl_pos::usize, ?sl, ?sc);

    var el: usize = 0;
    var ec: usize = 0;
    if (decl_len > 0) {
        workspace.offset_to_position(doc, (decl_pos + decl_len)::usize, ?el, ?ec);
    }
    or {
        el = sl;
        ec = sc + 1;
    }

    # build { "range": {...}, "placeholder": "name" }
    val result_str: str = build_prepare_rename_json(sym.name, sl, sc, el, ec, a);
    if (result_str != nil) {
        send_result(srv, id, result_str);
        free_str(result_str, a);
    }
    or {
        send_null_result(srv, id);
    }

    free_str(uri, a);
    free_str(id, a);
}

pub fun handle_rename(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);
    if (id == nil) { ret; }

    val td_anchor: str = "\"textDocument\"";
    val uri: str = json.extract_after(body, td_anchor, "\"uri\"", a);

    val pos_anchor: str = "\"position\"";
    val line: i64 = json.extract_number_after(body, pos_anchor, "\"line\"", a);
    val character: i64 = json.extract_number_after(body, pos_anchor, "\"character\"", a);

    val new_name: str = json.extract_string(body, "\"newName\"", a);

    if (uri == nil || new_name == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }

    # validate new name is not empty
    val new_name_len: usize = str_len(new_name);
    if (new_name_len == 0) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }

    # reject if new name is a keyword
    val tag: u8 = token.keyword_from_str(new_name);
    if (tag != token.TAG_IDENT) {
        send_error(srv, id, -32602, "new name is a keyword");
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }

    val doc: *workspace.Document = workspace.find(?srv.ws, uri);
    if (doc == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }

    val ar: *analysis.AnalysisResult = analysis.get_analysis(?srv.ac, doc, ?srv.ws);
    if (ar == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }

    val offset: usize = workspace.position_to_offset(doc, line::usize, character::usize);
    val node: *ast.Node = analysis.find_node_at_offset(ar.root, offset::i32);
    if (node == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }

    val sym: *symbol.Symbol = analysis.get_node_symbol(node);
    if (sym == nil) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }

    # reject external/module symbols
    if (sym.kind == symbol.SYM_EXT || sym.kind == symbol.SYM_MODULE) {
        send_error(srv, id, -32602, "cannot rename external or module symbol");
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }

    # collect references (including declaration)
    val max_refs: i32 = 1024;
    val refs_res: Result[**ast.Node, allocator.AllocError] =
        allocator.allocator_alloc[*ast.Node](?a, max_refs::usize);
    if (!refs_res.tag) {
        send_null_result(srv, id);
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }
    val refs: **ast.Node = refs_res.value.ok;

    val ref_count: i32 = analysis.collect_references(ar.root, sym, true, refs, max_refs);
    if (ref_count == 0) {
        send_null_result(srv, id);
        allocator.allocator_free[*ast.Node](?a, refs, max_refs::usize);
        free_str(uri, a);
        free_str(new_name, a);
        free_str(id, a);
        ret;
    }

    # build WorkspaceEdit: { "changes": { "<uri>": [ TextEdit, ... ] } }
    val result_str: str = build_workspace_edit_json(doc, refs, ref_count, new_name, a);
    if (result_str != nil) {
        send_result(srv, id, result_str);
        free_str(result_str, a);
    }
    or {
        send_null_result(srv, id);
    }

    allocator.allocator_free[*ast.Node](?a, refs, max_refs::usize);
    free_str(uri, a);
    free_str(new_name, a);
    free_str(id, a);
}

pub fun handle_completion(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);
    if (id != nil) {
        # TODO: #8 — scope-aware symbol completion
        send_result(srv, id, "[]");
        free_str(id, a);
    }
}

pub fun handle_document_symbol(srv: *lsp_types.Server, body: str) {
    var a: allocator.Allocator = srv.alloc;
    val id: str = json.extract_raw(body, "\"id\"", a);
    if (id != nil) {
        # TODO: #5 — walk AST for document symbols
        send_result(srv, id, "[]");
        free_str(id, a);
    }
}

# ============================================================================
# internal utilities
# ============================================================================

fun append(buf: *u8, offset: usize, s: str) usize {
    if (s != nil) {
        val slen: usize = str_len(s);
        if (slen > 0) {
            mem.raw_copy((buf + offset)::ptr, s::ptr, slen);
        }
        ret offset + slen;
    }
    ret offset;
}

fun wrap_in_array(json_str: str, alloc: allocator.Allocator) str {
    if (json_str == nil) { ret nil; }
    val len: usize = str_len(json_str);
    val total: usize = len + 2;
    var a: allocator.Allocator = alloc;
    val res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, total + 1);
    if (!res.tag) { ret nil; }
    val buf: *u8 = res.value.ok;
    buf[0] = '[';
    val one: usize = 1;
    mem.raw_copy((buf + one)::ptr, json_str::ptr, len);
    buf[len + one] = ']';
    buf[total] = 0;
    ret buf::str;
}

fun build_location_json(
    uri: str, start_line: usize, start_char: usize,
    end_line: usize, end_char: usize,
    alloc: allocator.Allocator
) str {
    var a: allocator.Allocator = alloc;

    val quoted_uri: str = json.quote(uri, a);
    val sl: str = json.format_usize(start_line, a);
    val sc: str = json.format_usize(start_char, a);
    val el: str = json.format_usize(end_line, a);
    val ec: str = json.format_usize(end_char, a);

    val p1: str = "{\"uri\":";
    val p2: str = ",\"range\":{\"start\":{\"line\":";
    val p3: str = ",\"character\":";
    val p4: str = "},\"end\":{\"line\":";
    val p5: str = ",\"character\":";
    val p6: str = "}}}";

    var qu_len: usize = 0;
    if (quoted_uri != nil) { qu_len = str_len(quoted_uri); }
    var sl_len: usize = 0;
    if (sl != nil) { sl_len = str_len(sl); }
    var sc_len: usize = 0;
    if (sc != nil) { sc_len = str_len(sc); }
    var el_len: usize = 0;
    if (el != nil) { el_len = str_len(el); }
    var ec_len: usize = 0;
    if (ec != nil) { ec_len = str_len(ec); }

    val total: usize = str_len(p1) + qu_len + str_len(p2) + sl_len + str_len(p3) + sc_len +
                       str_len(p4) + el_len + str_len(p5) + ec_len + str_len(p6);

    val buf_res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, total + 1);
    if (!buf_res.tag) {
        free_str(quoted_uri, a);
        free_str(sl, a);
        free_str(sc, a);
        free_str(el, a);
        free_str(ec, a);
        ret nil;
    }
    val buf: *u8 = buf_res.value.ok;

    var off: usize = 0;
    off = append(buf, off, p1);
    off = append(buf, off, quoted_uri);
    off = append(buf, off, p2);
    off = append(buf, off, sl);
    off = append(buf, off, p3);
    off = append(buf, off, sc);
    off = append(buf, off, p4);
    off = append(buf, off, el);
    off = append(buf, off, p5);
    off = append(buf, off, ec);
    off = append(buf, off, p6);
    buf[off] = 0;

    free_str(quoted_uri, a);
    free_str(sl, a);
    free_str(sc, a);
    free_str(el, a);
    free_str(ec, a);

    ret buf::str;
}

fun build_locations_json(
    doc: *workspace.Document, refs: **ast.Node, count: i32,
    alloc: allocator.Allocator
) str {
    if (count == 0) { ret nil; }

    var a: allocator.Allocator = alloc;

    # build each location string and compute total length
    val locs_res: Result[*str, allocator.AllocError] =
        allocator.allocator_alloc[str](?a, count::usize);
    if (!locs_res.tag) { ret nil; }
    val locs: *str = locs_res.value.ok;

    var total: usize = 2;  # "[]"
    var i: i32 = 0;
    for (i < count) {
        val ref_node: *ast.Node = refs[i];
        val ref_pos: i32 = ref_node.tok.pos;
        val ref_len: i32 = ref_node.tok.len;

        var sl: usize = 0;
        var sc: usize = 0;
        workspace.offset_to_position(doc, ref_pos::usize, ?sl, ?sc);

        var el: usize = 0;
        var ec: usize = 0;
        if (ref_len > 0) {
            workspace.offset_to_position(doc, (ref_pos + ref_len)::usize, ?el, ?ec);
        }
        or {
            el = sl;
            ec = sc + 1;
        }

        val loc: str = build_location_json(doc.uri, sl, sc, el, ec, a);
        locs[i] = loc;
        if (loc != nil) { total = total + str_len(loc); }
        if (i > 0) { total = total + 1; }  # comma
        i = i + 1;
    }

    val buf_res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, total + 1);
    if (!buf_res.tag) {
        i = 0;
        for (i < count) { free_str(locs[i], a); i = i + 1; }
        allocator.allocator_free[str](?a, locs, count::usize);
        ret nil;
    }
    val buf: *u8 = buf_res.value.ok;

    var off: usize = 0;
    buf[off] = '[';
    off = off + 1;

    i = 0;
    for (i < count) {
        if (i > 0) {
            buf[off] = ',';
            off = off + 1;
        }
        off = append(buf, off, locs[i]);
        i = i + 1;
    }

    buf[off] = ']';
    off = off + 1;
    buf[off] = 0;

    i = 0;
    for (i < count) { free_str(locs[i], a); i = i + 1; }
    allocator.allocator_free[str](?a, locs, count::usize);

    ret buf::str;
}

fun build_prepare_rename_json(
    name: str, start_line: usize, start_char: usize,
    end_line: usize, end_char: usize,
    alloc: allocator.Allocator
) str {
    var a: allocator.Allocator = alloc;

    val quoted_name: str = json.quote(name, a);
    val sl: str = json.format_usize(start_line, a);
    val sc: str = json.format_usize(start_char, a);
    val el: str = json.format_usize(end_line, a);
    val ec: str = json.format_usize(end_char, a);

    val p1: str = "{\"range\":{\"start\":{\"line\":";
    val p2: str = ",\"character\":";
    val p3: str = "},\"end\":{\"line\":";
    val p4: str = ",\"character\":";
    val p5: str = "}},\"placeholder\":";
    val p6: str = "}";

    var qn_len: usize = 0;
    if (quoted_name != nil) { qn_len = str_len(quoted_name); }
    var sl_len: usize = 0;
    if (sl != nil) { sl_len = str_len(sl); }
    var sc_len: usize = 0;
    if (sc != nil) { sc_len = str_len(sc); }
    var el_len: usize = 0;
    if (el != nil) { el_len = str_len(el); }
    var ec_len: usize = 0;
    if (ec != nil) { ec_len = str_len(ec); }

    val total: usize = str_len(p1) + sl_len + str_len(p2) + sc_len +
                       str_len(p3) + el_len + str_len(p4) + ec_len +
                       str_len(p5) + qn_len + str_len(p6);

    val buf_res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, total + 1);
    if (!buf_res.tag) {
        free_str(quoted_name, a);
        free_str(sl, a);
        free_str(sc, a);
        free_str(el, a);
        free_str(ec, a);
        ret nil;
    }
    val buf: *u8 = buf_res.value.ok;

    var off: usize = 0;
    off = append(buf, off, p1);
    off = append(buf, off, sl);
    off = append(buf, off, p2);
    off = append(buf, off, sc);
    off = append(buf, off, p3);
    off = append(buf, off, el);
    off = append(buf, off, p4);
    off = append(buf, off, ec);
    off = append(buf, off, p5);
    off = append(buf, off, quoted_name);
    off = append(buf, off, p6);
    buf[off] = 0;

    free_str(quoted_name, a);
    free_str(sl, a);
    free_str(sc, a);
    free_str(el, a);
    free_str(ec, a);

    ret buf::str;
}

fun build_workspace_edit_json(
    doc: *workspace.Document, refs: **ast.Node, count: i32,
    new_name: str, alloc: allocator.Allocator
) str {
    if (count == 0) { ret nil; }

    var a: allocator.Allocator = alloc;

    # build text edits array
    val edits_res: Result[*str, allocator.AllocError] =
        allocator.allocator_alloc[str](?a, count::usize);
    if (!edits_res.tag) { ret nil; }
    val edits: *str = edits_res.value.ok;

    val quoted_new_name: str = json.quote(new_name, a);

    var edits_total: usize = 0;
    var i: i32 = 0;
    for (i < count) {
        val ref_node: *ast.Node = refs[i];
        val ref_pos: i32 = ref_node.tok.pos;
        val ref_len: i32 = ref_node.tok.len;

        var sl: usize = 0;
        var sc: usize = 0;
        workspace.offset_to_position(doc, ref_pos::usize, ?sl, ?sc);

        var el: usize = 0;
        var ec: usize = 0;
        if (ref_len > 0) {
            workspace.offset_to_position(doc, (ref_pos + ref_len)::usize, ?el, ?ec);
        }
        or {
            el = sl;
            ec = sc + 1;
        }

        val edit: str = build_text_edit_json(sl, sc, el, ec, quoted_new_name, a);
        edits[i] = edit;
        if (edit != nil) { edits_total = edits_total + str_len(edit); }
        if (i > 0) { edits_total = edits_total + 1; }  # comma
        i = i + 1;
    }

    # build: {"changes":{"<uri>":[edit1,edit2,...]}}
    val quoted_uri: str = json.quote(doc.uri, a);

    val h1: str = "{\"changes\":{";
    val h2: str = ":[";
    val h3: str = "]}}";

    var qu_len: usize = 0;
    if (quoted_uri != nil) { qu_len = str_len(quoted_uri); }

    val total: usize = str_len(h1) + qu_len + str_len(h2) + edits_total + str_len(h3);

    val buf_res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, total + 1);
    if (!buf_res.tag) {
        i = 0;
        for (i < count) { free_str(edits[i], a); i = i + 1; }
        allocator.allocator_free[str](?a, edits, count::usize);
        free_str(quoted_uri, a);
        free_str(quoted_new_name, a);
        ret nil;
    }
    val buf: *u8 = buf_res.value.ok;

    var off: usize = 0;
    off = append(buf, off, h1);
    off = append(buf, off, quoted_uri);
    off = append(buf, off, h2);

    i = 0;
    for (i < count) {
        if (i > 0) {
            buf[off] = ',';
            off = off + 1;
        }
        off = append(buf, off, edits[i]);
        i = i + 1;
    }

    off = append(buf, off, h3);
    buf[off] = 0;

    i = 0;
    for (i < count) { free_str(edits[i], a); i = i + 1; }
    allocator.allocator_free[str](?a, edits, count::usize);
    free_str(quoted_uri, a);
    free_str(quoted_new_name, a);

    ret buf::str;
}

fun build_text_edit_json(
    start_line: usize, start_char: usize,
    end_line: usize, end_char: usize,
    quoted_new_text: str, alloc: allocator.Allocator
) str {
    var a: allocator.Allocator = alloc;

    val sl: str = json.format_usize(start_line, a);
    val sc: str = json.format_usize(start_char, a);
    val el: str = json.format_usize(end_line, a);
    val ec: str = json.format_usize(end_char, a);

    val p1: str = "{\"range\":{\"start\":{\"line\":";
    val p2: str = ",\"character\":";
    val p3: str = "},\"end\":{\"line\":";
    val p4: str = ",\"character\":";
    val p5: str = "}},\"newText\":";
    val p6: str = "}";

    var sl_len: usize = 0;
    if (sl != nil) { sl_len = str_len(sl); }
    var sc_len: usize = 0;
    if (sc != nil) { sc_len = str_len(sc); }
    var el_len: usize = 0;
    if (el != nil) { el_len = str_len(el); }
    var ec_len: usize = 0;
    if (ec != nil) { ec_len = str_len(ec); }
    var qnt_len: usize = 0;
    if (quoted_new_text != nil) { qnt_len = str_len(quoted_new_text); }

    val total: usize = str_len(p1) + sl_len + str_len(p2) + sc_len +
                       str_len(p3) + el_len + str_len(p4) + ec_len +
                       str_len(p5) + qnt_len + str_len(p6);

    val buf_res: Result[*u8, allocator.AllocError] = allocator.allocator_alloc[u8](?a, total + 1);
    if (!buf_res.tag) {
        free_str(sl, a);
        free_str(sc, a);
        free_str(el, a);
        free_str(ec, a);
        ret nil;
    }
    val buf: *u8 = buf_res.value.ok;

    var off: usize = 0;
    off = append(buf, off, p1);
    off = append(buf, off, sl);
    off = append(buf, off, p2);
    off = append(buf, off, sc);
    off = append(buf, off, p3);
    off = append(buf, off, el);
    off = append(buf, off, p4);
    off = append(buf, off, ec);
    off = append(buf, off, p5);
    off = append(buf, off, quoted_new_text);
    off = append(buf, off, p6);
    buf[off] = 0;

    free_str(sl, a);
    free_str(sc, a);
    free_str(el, a);
    free_str(ec, a);

    ret buf::str;
}

fun free_str(s: str, alloc: allocator.Allocator) {
    if (s != nil) {
        val len: usize = str_len(s);
        var a: allocator.Allocator = alloc;
        allocator.allocator_free_bytes(?a, s::ptr, len + 1, 1);
    }
}
